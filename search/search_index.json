{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the ETOPay SDK documentation. This comprehensive guide is designed to provide you with all the information you need to install and use the ETOPay SDK effectively.</p> <p>The ETOPay SDK provides the logic for interacting with the ETOPay backend correctly. The SDK plans to help developers with a quicker, safer and easier on-boarding in the web3 world, while using the ETOPay infrastructure to support various use-cases around data monetization.</p> <p>The SDK is divided in various modules which come together to ensure an easy and safe way to incorporate the SDK in the application.</p> <p>For ease of integration, the SDK also generates bindings in various languages for various platforms, especially for mobile platforms, to provide easy integration with native and hybrid mobile app development frameworks.</p> <p>This documentation is primarily intended for developers who are integrating the ETOPay SDK into their applications. It provides a comprehensive guide to installing and using the SDK, with a focus on practical examples and clear, concise explanations.</p> <p>The documentation is divided into following sections. Simply choose one and get started!</p> <ul> <li> <p> Features</p> <p>Know the features before using ETOPay in your applications for a better product-market fit.</p> <p> Architecture</p> </li> <li> <p> Set up the SDK</p> <p>This section provides step-by-step instructions on how to install the ETOPay SDK in your development environment.</p> <p> Install</p> </li> <li> <p> Configuring the SDK</p> <p>Here, you'll find information on how to use the SDK's basic features and configure it correctly, complete with code snippets and examples to help you get started.</p> <p> Configure</p> </li> <li> <p> SDK Modules</p> <p>Once you're comfortable with the basics and configuration, this section delves into the core SDK module functions around user and wallet management, kyc onboarding processes, integration with exchanges, helping you leverage the full power of the ETOPay SDK.</p> <p> Modules</p> </li> <li> <p> API Reference</p> <p>This section provides a detailed overview of the SDK's API, including descriptions of the different functions, their return values, and the error types you might encounter.</p> <p> Reference</p> </li> <li> <p> SDK Examples</p> <p>This section provides a basic overview of the SDK internal structure and explains the different modules and their functions intrinsically.</p> <p> Examples</p> </li> </ul> <p>We hope this documentation serves as a valuable resource to explore the capabilities of the ETOPay SDK.</p> <p>Made with  by Team Lobster </p>"},{"location":"Choosing%20ETOPay/Architecture/","title":"Architecture","text":""},{"location":"Choosing%20ETOPay/Architecture/#overview","title":"Overview","text":"<p>The architecture shows the involved participants and explains how the integration of a client application works with .</p>"},{"location":"Choosing%20ETOPay/Architecture/#services","title":"Services","text":"<p>The ETOPay services are a bundle of services, which work together, using various infrastructure components like databases, message queues, caches, etc... to provide the different features as listed here</p> <p>These services are maintained, tested and updated by the development team behind this project. The source code for the same is maintained in a closed source repository with the development team.</p>"},{"location":"Choosing%20ETOPay/Architecture/#web-portal","title":"Web portal","text":"<p>The developers trying to integrate the ETOPay SaaS product would typically access the web portal to register themselves. After the registration, the developer can requisition a fresh new instance for the application from ETOPay through this portal.</p> <p>Additionally, the web portal allows the developers to configure their instance according to their application needs. It can be also used to undertake some application specific settings and modify them as well. For example, setting the identity provider urls and access points, which is owned by the application but may be used by ETOPay to authenticate users or setting a webhook receiver endpoint, where a notification server is already listening to ETOPay internal events, to push notifications to the end-user devices, etc...</p> <p>Currently, on the first request, a staging environment of a fresh ETOPay services instance is deployed. This allows the developers to test their application flow and integration with ETOPay before moving to production. Requesting a production instance is an extra step which needs to be done additionally. This helps the developers to fix a version for their production, while they continue testing new features and releases from ETOPay team on the staging environment, before requesting to update to production.</p> <p>The infrastructure deploys in a private cloud hosted in the european data center. Deployments in client infrastructure and public clouds are currently not possible, however will be considered in the future, for example with client-owned kubernetes cluster or Azure/AWS depolyments. The ETOPay services are coded in software to be fully platform agnostic. Hence, the deployment architecture does not affect the features and working of the services.</p>"},{"location":"Choosing%20ETOPay/Architecture/#integration","title":"Integration","text":"<p>The integration can occur for the client in three different ways:</p> <ol> <li> <p>REST API: A platform-agnostic, robust API to interact with the  features and a modern and sleek documentation.</p> <p>Within this integration, the ETOPay services are exposed via a REST API. The client developers can directly connect to these services using the Open API specification for the services. A drawback for this approach could be that the requirement on the various flows as expected by the ETOPay services needs to be well understood from the documentation. This approach also works only with custodial wallets, which might increase costs for end-users, as compared to a self-custody wallet.</p> </li> <li> <p>SDK: A variety of multi-stack SDKs working together to allow seamless in-app integration with code examples and instructions on best-practices.</p> <p>Here, the client developers can download our SDKs and even modify their behaviour according to their own needs. These SDKs are described in detail and the source code is kept open to allow maximum benefit during integration. Using the SDK gives the advantage to the developers in a way that, the SDK does all the heavy lifting in terms of executing the flows together with the ETOPay service whilst ensuring secure self-custody wallets and user management on end-user devices. This takes away a significant amount of integration effort and allows for a quick time-to-market without needing to understand all particular nuances of ETOPay services.</p> </li> <li> <p>White Label App: A multi-platform white label application with intuitive interfaces for low time to market with fully compliant flows to ensure highest user satisfaction.</p> <p>As the white label application builds on top of the SDK, it provides the client developers with complete UI/UX for maximum integration with minimal effort. The only thing the client developers would need is to adjust the corporate identiy, build the application and ship it to their end-users. The white label app ensures that all the flows are correctly executed, with the most lucid user experience from on-boarding to using the features of ETOPay. Being open source again, the white label application can also be customized for own needs and making an entirely new application would be like simply adding a few new layouts.</p> </li> </ol>"},{"location":"Choosing%20ETOPay/Features/","title":"Features","text":"<p>allows end-users to perform in-app payments to other end-users for services and products offered through the application.</p> <p>solves the problem of P2P payments between end-users, by not becoming a gate-keeper, but a path-finder between consumers for digital data, services and real-world commodities</p> <ul> <li> <p>Complete Wallet Management with MFA (Multi-factor approvals)</p> <p>For end-users with custodial and non-custodial cryptocurrency wallets without the need of additional approval from regulatory authorities</p> </li> <li> <p>KYC onboarding</p> <p>A completed on-boarding with a full-KYC without ever needing to leave the application and jumping in different browsers.</p> </li> <li> <p>Fiat/Cryptocurrency integration</p> <p>Allows loading cryptocurrency wallets from FIAT bank accounts and vice versa all within the application. Hassle-free and no copy pasting strange character addresses in even stranger browser apps.</p> </li> <li> <p>Multi-user app</p> <p>One end-user or multiple end-users on a single device? We have you covered. Every user on the same end-device can work with the highest assurance that their data cannot be seen by anyone else except themselves.</p> </li> <li> <p>Seamless identity integration</p> <p>We integrate directly with our existing identity providers, to avoid the confusion of re-registration and doing the onboarding for the users again.</p> </li> <li> <p>Integrated invoice and receipt</p> <p>The users need not worry for being conform with the tax authorities. We generate the legally exact receipts and invoices for every user automatically.</p> </li> <li> <p>Multi-platform compatible</p> <p>The solution is provided as an SDK (Software Development Kit) for major application platforms like Android, iOS and Web for developer-easy integration.</p> </li> <li> <p>European Data Center</p> <p>All your data stays in EU and never leaves, replicated or sold to anyone. A fully (really!) GDPR compliant solution with no non-EU entities lurking in the shadows of privacy policy.</p> </li> <li> <p>Cyber-secure</p> <p>A periodic vulnerability assessment and penetration testing ensures that the system is robust against attacks and leaks.</p> </li> </ul>"},{"location":"Choosing%20ETOPay/Features/#use-cases","title":"Use-cases","text":"<p>With ETOPay, you can do a lot more than the listed use-cases below. The use-cases just simply show the tip of the iceberg, how you can benefit from integrating ETOPay in your applications:</p> <ol> <li>Data-Marketplace for buying and selling sensor data, digital content or even NFTs.</li> <li>A simple cart checkout with multiple payment and currency options</li> <li>Artist remuneration directly in app for major events</li> <li>A DeFi dApp with a fully embedded wallet, without needing users to download and install shady plugins.</li> <li>Gaming exchanges for in-game artifacts and digital content with exclusive content mangement rights negotiated in real-time between end-users.</li> <li>Scam detection and regulated payments to health-care related products for the elderly</li> </ol>"},{"location":"Choosing%20ETOPay/Licensing/","title":"Licensing","text":""},{"location":"Choosing%20ETOPay/Licensing/#software-licensing-and-open-source","title":"Software licensing and open source","text":"<p>We are planning to make the SDK open source and start accepting contribution from the community.</p> <p>However, till we decide on the best way to move forward with various open source licensing options available, that might suit our needs as well as benefit the developer community, we are currently delivering the SDK under a strict license as shown on the footer of this website.</p>"},{"location":"Choosing%20ETOPay/Licensing/#license","title":"License","text":"<p> 2025 ETOSPHERES Labs GmbH, All rights reserved.</p>"},{"location":"Choosing%20ETOPay/Philosophy/","title":"Philosophy","text":"<p>The ETOPay project was started with a few basic principles and they are also the guiding values which will continue to motivate the team and all its contributors to work for this project.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#core-principles","title":"Core principles","text":"<p>The following core principles summarize how the team looks at things differently:</p>"},{"location":"Choosing%20ETOPay/Philosophy/#self-realization","title":"Self-realization","text":"<p>Identify the problem: It is always important for us to identify the core problem on the technical front and approach it as an engineer with fixed boundary conditions. It is crucial to understand and realize the crux of a certain system to also get to the core of the underlying problem, rather than waiting for anyone else to explain to us their view of the system and problem.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#awareness","title":"Awareness","text":"<p>Look for solutions: Look around at other people, who might have faced the same problem and look at the solutions they are using. Look at other solutions in totally different systems but with the same problems and see if they are a fit for your problem. Most of the times, the buck stops here and the problem is solved with a possible solution being discovered. But, we do care for one more core principle which influences entirely as to why certain solutions are not the best fits.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#fairness","title":"Fairness","text":"<p>Is it allowed? Not just in terms of legal, but in terms of morality as well. It is very important to consider the sentiments of each and every human and especially their rights, when they interact with our systems. Legally speaking, there might be some grey areas, but morally there are plainly some things which we cannot just allow on principle. And mostly this is how we judge the solutions and the philosophies behind them, as how they would affect us and in turn our customers.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#dexterity","title":"Dexterity","text":"<p>DIY: If there is no solution which is legally and morally correct, or no solution technically at all, then it becomes the time for us to get our hands dirty and dive in completely to solve the problem from its roots and come up with a solution that provides us a way out of the problem once and for all. Resources become no concern as the best available methods, processes and people get attracted to us when we approach a well-aware core problem with fairness also in focus.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#community","title":"Community","text":"<p>One-for-all and all-for one: We strongly believe that we should be rewarded for what we do. And this is also sometimes a driver and motivation behind searching for solutions. In addition, we also equally strongly believe that we do not want to become gate-keepers but path-finders and light-bringers for others like us, searching for solutions in the dark. Putting back our efforts to the community, in a way which allows a beautiful, sustainable ecosystem to flourish makes complete sense, when we start contemplating that, the solutions would themselves never exist, if not for the base provided by the same thriving community.</p> <p>With these core principles guiding us, we just rinse and repeat at every opportunity that comes in-front of us either as a special request, challenge or self-discovered problems. We are affirmed more than once that this belief in the core principles has potential to rescue the world trapped under various gate-keepers to a truly decentralized and fair ecosystem.</p> <p>Hence, it does not come to us as a surprise that, all which we are building fits perfectly in the Web3 context, which also strives to unite over marginalizing or dividing people.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#the-etopay-story","title":"The ETOPay story","text":"<p>began exactly with the simplest of problems: How is it possible for a person to pay another person for goods and services offered on a platform in a way where the platform is not a gate-keeper?</p> <p>With this started our search for solutions and we concluded that there is no platform as such which respects their end-users and their rights like data protection, but rather tries to exploit as much as they can from their users.</p> <p>We started developing ETOPay and we realized that we actually are just using various solutions, which are already available in the community, but just presenting and connecting them in a way that makes it fair, legal and transparent.</p> <p>Taking guidance from our core principles, we have decided to go open source with our solution and give it to the community, not just to help develop it further with us but also use it everywhere, where they encountered gate-keepers. To employ it in a way which guarantees fairness and transparency to their end users, baked right in the solution.</p>"},{"location":"Installing%20the%20SDK/Installation/","title":"Installation","text":"<p>For installing the SDK, follow the steps detailed for each ecosystem. Currently the SDK supports the following languages/stacks:</p> <ul> <li>Rust</li> <li>Java</li> <li>Swift (for iOS)</li> <li>JavaScript / TypeScript</li> </ul> <p>Further support for other languages &amp; ecosystems can be requested to the SDK team by contacting the maintainers of this document or reaching out directly to us @ ETOSPHERES Labs GmbH.</p>"},{"location":"Installing%20the%20SDK/JS_TS/","title":"Javascript/Typescript Installation","text":"<p>The JS/TS SDK is delivered as a <code>.tgz</code> compressed NPM package file, ready for inclusion into any project using a NPM compatible package manager. Currently, the package is designed for being compatible with popular bundlers such as <code>webpack</code> and <code>vite</code><sup>1</sup> , and comes with TypesScript type definitions as well as ergonomic JavaScript wrappers. These instructions assume that you already have a project setup using one of the supported bundlers.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#installing-the-jsts-sdk","title":"Installing the JS/TS SDK","text":"<p>To install the WASM SDK, simply place the compressed file next to your project and use <code>npm</code>/<code>pnpm</code> to install it from your project directory (the one containing your <code>project.json</code> file):</p> <pre><code>npm install &lt;path-to-the-tgz-file&gt;\n</code></pre> <p>The package can then be used within your application like so (example using <code>webpack</code>):</p> <pre><code>import { ETOPaySdk, Environment, Level } from \"@eto/etopay-sdk-wasm\";\n\nconst sdk = await new ETOPaySdk();\nsdk.initLogger(Level.Info);\nawait sdk.setEnvironment(Environment.Development);\nawait sdk.validateConfig();\n</code></pre> <p>or using a named import:</p> <pre><code>import * as ETOPay from \"@eto/etopay-sdk-wasm\";\n\nconst sdk = new ETOPay.ETOPaySdk();\nsdk.initLogger(ETOPay.Level.Info);\nawait sdk.setEnvironment(ETOPay.Environment.Development);\nawait sdk.validateConfig();\n</code></pre> <p>See the API reference for more information about the available functions.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#updating-the-jsts-sdk","title":"Updating the JS/TS SDK","text":"<p>Updating the SDK is simply replacing the file and performing the steps above again.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#future-releases-of-the-jsts-sdk","title":"Future releases of the JS/TS SDK","text":"<p>Future releases of the SDK for JS/TS will be published to the NPM registry, for even easier installation.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#minimum-supported-version","title":"Minimum supported version","text":"<p>The bindings have been tested to work with <code>webpack</code> v4.47.0.</p> <ol> <li> <p>If the current package does not work for you, and you for example need a package for inclusion directly on a web page as a <code>&lt;script&gt;</code> tag, please reach out to the development team.\u00a0\u21a9</p> </li> </ol>"},{"location":"Installing%20the%20SDK/Java/","title":"Java Installation","text":"<p>The Java SDK is now available through a private Maven repository hosted on JFrog. You can add it as a dependency in your Maven project's <code>pom.xml</code> file.</p>"},{"location":"Installing%20the%20SDK/Java/#installing-via-maven-repository","title":"Installing via Maven Repository","text":"<ol> <li> <p>Update <code>settings.xml</code></p> <p>To access the private Maven repository, you need to update your Maven <code>settings.xml</code> file, usually located in the <code>~/.m2</code> directory. Add the following server configuration:</p> <pre><code>&lt;servers&gt;\n&lt;server&gt;\n    &lt;id&gt;jfrog-private-repo&lt;/id&gt;\n    &lt;username&gt;your-username&lt;/username&gt;\n    &lt;password&gt;your-password&lt;/password&gt;\n    &lt;/server&gt;\n&lt;/servers&gt;\n</code></pre> <p>Note: Replace <code>your-username</code> and <code>your-password</code> with your actual JFrog repository credentials.</p> </li> <li> <p>Update your projects <code>pom.xml</code> file to include the <code>dependency</code> and the <code>repository</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.etogruppe&lt;/groupId&gt;\n    &lt;artifactId&gt;ETOPaySdk&lt;/artifactId&gt;\n    &lt;version&gt;0.11.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>&lt;repositories&gt;\n&lt;repository&gt;\n    &lt;id&gt;snapshots-repo&lt;/id&gt;\n    &lt;url&gt;https://repo.farmunited.com:443/artifactory/egdbz-mvn/&lt;/url&gt;\n    &lt;releases&gt;\n    &lt;enabled&gt;false&lt;/enabled&gt;\n    &lt;/releases&gt;\n    &lt;snapshots&gt;\n    &lt;enabled&gt;true&lt;/enabled&gt;\n    &lt;/snapshots&gt;\n&lt;/repository&gt;\n&lt;/repositories&gt;\n</code></pre> </li> </ol> <p>See JFrog Artifactory Documentation &gt; Package Management &gt; Maven Repository for guiding docs.</p>"},{"location":"Installing%20the%20SDK/Java/#installing-jnilibs","title":"Installing jniLibs","text":"<p>The jar files also contain the jniLibs folder. The jniLibs folder in turn contains the pre-built shared object libraries of the SDK. The structure of the folder is as shown below:</p> <pre><code>jniLibs\n\u251c\u2500\u2500 arm64-v8a\n\u2502   \u251c\u2500\u2500 libetopaysdk.so\n\u2502   \u2514\u2500\u2500 libc++_shared.so\n\u251c\u2500\u2500 armeabi-v7a\n\u2502   \u251c\u2500\u2500 libetopaysdk.so\n\u2502   \u2514\u2500\u2500 libc++_shared.so\n\u251c\u2500\u2500 x86\n\u2502   \u251c\u2500\u2500 libetopaysdk.so\n\u2502   \u2514\u2500\u2500 libc++_shared.so\n\u2514\u2500\u2500 x86_64\n    \u251c\u2500\u2500 libetopaysdk.so\n    \u2514\u2500\u2500 libc++_shared.so\n</code></pre> <p>The <code>jniLibs</code> folder should be placed as-is under the <code>src/main</code> folder of the corresponding Java project from the jar file.</p> <p>Warning</p> <p>Currently the moving of the jniLibs from the jar to the src/main folder is manual and not automated. Later it will be automated with a gradle plugin once the project is moved to open source. Not copying this generally will throw the error while initializing the constructor of the ETOPaySdk class <code>java.lang.UnsatisfiedLinkError: dlopen failed: library \"libetopaysdk.so\" not found</code>.</p>"},{"location":"Installing%20the%20SDK/Java/#future-releases-of-sdk","title":"Future releases of SDK","text":"<p>Future releases of the SDK will continue to be published to the private Maven repository. You will only need to update the dependency version in your pom.xml file to use the latest release and replace the jniLibs correspondingly.</p>"},{"location":"Installing%20the%20SDK/Java/#minimum-version-support","title":"Minimum version support","text":"<p>The following versions of the toolchain are used to build and compile the Java SDK and should be used as minimum versions for integrating the SDK. Versions lower than the mentioned might work, however are not guaranteed by the team. In case of issues, please contact the team with specific build or compile errors.</p> <ul> <li>Java Compiler: <code>17.0.10</code></li> <li>gradle: <code>Gradle 8.6</code></li> <li>Android SDK Command-line Tools:  <code>12.0</code></li> <li>Android SDK Platform: <code>Android SDK Platform 13</code></li> <li>Android API Level: <code>33</code></li> <li>Android NDK: <code>26.2.11394342</code></li> <li>Android Build Tools: <code>34.0.0</code></li> </ul>"},{"location":"Installing%20the%20SDK/Rust/","title":"Rust Installation","text":"<p>Info</p> <p>The Rust SDK is currently in a pre-release state and is not yet available on the crates.io registry. </p> <p>You can access the SDK by adding the following dependency to your <code>Cargo.toml</code> file:</p> <pre><code>[dependencies]\netopay-sdk = { git = \"https://github.com/ETOSPHERES-Labs/etopay-sdk\", branch = \"main\", package =\"etopay-sdk\" }\n</code></pre> <p>You can also checkout the etopay-sdk-quickstart-rs repository for a quickstart guide on how to use the SDK in your Rust project.</p>"},{"location":"Installing%20the%20SDK/Swift/","title":"Swift Installation","text":"<p>The swift SDK is now available through a private gitlab repository with binaries hosted on JFrog. You can add the repository as a <code>dependency</code> in your <code>Package.swift</code>. Before starting, make sure you have access to the Gitlab repository as it will be needed for the instructions below.</p> <p>We provide binaries for the following platforms:</p> <ul> <li><code>aarch64-apple-ios</code>: targets 64-bit ARM processors for iOS devices like iPhones and iPads.</li> <li><code>x86_64-apple-ios</code>: for 64-bit Intel processors for iOS simulators.</li> <li><code>aarch64-apple-ios-sim</code>: for 64-bit ARM processors running iOS simulators, typically used on Apple Silicon Macs.</li> <li><code>aarch64-apple-darwin</code>: for 64-bit ARM processors on macOS systems (eg. M1).</li> <li><code>x86_64-apple-darwin</code>: for 64-bit Intel processors on macOS systems.</li> </ul>"},{"location":"Installing%20the%20SDK/Swift/#using-etopay-with-swift-package-manager","title":"Using ETOPay with Swift Package Manager","text":"<p>The ETOPay SDK can also be used as a Swift package. Follow these steps to integrate it into your project:</p> <p>Add the repository as a <code>dependency</code> in your <code>Package.swift</code> file:</p> <pre><code>import PackageDescription\n\nlet package = Package(\n    name: \"program\",\n    dependencies: [\n        .package(url: \"https://github.com/ETOSPHERES-Labs/etopay-sdk-swift\", from: \"0.0.1\")\n    ],\n    targets: [\n        .executableTarget(\n            name: \"main\",\n            dependencies: [\n                .product(name: \"ETOPaySdk\", package: \"etopay-swift\")\n            ]),\n    ]\n)\n</code></pre> <p>The <code>ETOPaySdk</code> module will then be available for import in your project.</p>"},{"location":"Installing%20the%20SDK/Swift/#using-etopay-with-xcode","title":"Using ETOPay with XCode","text":"<p>In XCode, go to File -&gt; Add Package Dependencies. In the top right search box, enter the url of the GitLab repository (<code>https://github.com/ETOSPHERES-Labs/etopay-sdk-swift</code>) and select the ETOPay SDK when it appears in the list. Select Add Package and follow the on-screen instructions.</p>"},{"location":"Installing%20the%20SDK/Swift/#access-to-the-binaries-on-jfrog","title":"Access to the binaries on JFrog","text":"<p>To allow the Swift Package Manager and XCode to download the binaries stored in JFrog, you need to set up an access token in your <code>~/.netrc</code> file.</p> <ol> <li>Visit <code>JFrog</code> and log in. In the top right corner, click your name and then \"Edit Profile.\" Under \"Identity Tokens,\" click \"Generate an Identity Token\" and optionally give the token a name.</li> <li>If not already existing, create the file <code>.netrc</code> in your home folder and add the following lines (e.g., using <code>nano ~/.netrc</code>)</li> </ol> <pre><code>machine repo.farmunited.com\n    login &lt;your JFrog username&gt;\n    password &lt;your access token&gt;\n</code></pre> <ol> <li>You should now be able to access and use the package in your Swift projects!</li> </ol> <p>Note: you might need to restart XCode for the changes to take effect.</p>"},{"location":"Installing%20the%20SDK/Swift/#future-releases-of-sdk","title":"Future releases of SDK","text":"<p>Future releases of SDK will continue to be published on the private gitlab repository. You will only need to update the dependency version to use the latest release.</p>"},{"location":"Installing%20the%20SDK/Swift/#minimum-supported-version","title":"Minimum supported version","text":"<ul> <li>swift-tools - <code>5.8</code></li> <li>swiftlang- <code>swiftlang-5.8.0.124.2</code></li> <li>clang - <code>clang-1403.0.22.11.100</code></li> <li>iOS - <code>13</code></li> </ul>"},{"location":"SDK%20Configuration/Configuration/","title":"Configuring the SDK","text":"<p>The ETOPay SDK needs to be configured correctly for secure and functional usage. Misconfiguration might lead to potential information leaks as well as bad end-user experience.</p>"},{"location":"SDK%20Configuration/Configuration/#static-configuration","title":"Static Configuration","text":"<p>The static configuration is provided by passing a JSON formatted string to the SDK using the <code>set_config</code> function. It has the following format, whose fields are described in the sections below.</p> <pre><code>{\n    \"auth_provider\": \"&lt;authentication provider name&gt;\",\n    \"backend_url\": \"&lt;valid URL to the backend API&gt;\",\n    \"storage_path\": \"/path/to/valid/folder\",\n    \"log_level\": \"info\"\n}\n</code></pre>"},{"location":"SDK%20Configuration/Configuration/#configuring-authentication-provider","title":"Configuring authentication provider","text":"<p>The authentication provider is a setting which is configured in the beginning in conjunction with the ETOPay development team. The ETOPay SDK and backend support Oauth2.0/OpenID Connect<sup>1</sup> provider and can work with external authentication providers. The following information is needed by the ETOPay team to configure the backend to accept requests from the SDK:</p> <ol> <li>ISSUER - The issuer, which is part of the JWT claim in the <code>access_token</code>, created by the OAuth2.0 server. The issuer is generally the URL to the realm, but could also be different based on different settings.</li> <li>AUTHORITY - The authority is where the public keys/certificates are hosted, which are used by the OAuth2.0 server to sign the JWT <code>access_tokens</code>. This is mostly a URL of the following type: <code>{base_url}/auth/realms/{realm_name}/protocol/openid-connect/certs</code></li> <li>AZP - The authorized party, which is part of the JWT claim in the <code>access_token</code>, created by the OAuth2.0 server. The authorized party is typically the name of the 3rd-party client, which has requested the JWT Token for the user using various flows listed in the standard.</li> <li>NAME - A unique name to assign and identify this particular authentication provider settings in the backend as well as in the SDK. This is the name to specify in the <code>auth_provider</code> field of the configuration.</li> </ol> Info <p>The control of the client credentials, the flows used to fetch the JWT as well as the entire user management including user registration, email verification and user settings is out of scope for ETOPay backend and SDK. This should be managed by applications using the SDK themselves.</p> <p>Every time the OAuth client refreshes or fetches a new access token for the user, the access token can be updated in the SDK using the <code>refresh_access_token</code> function.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(\"...\").unwrap();\n\n    sdk.refresh_access_token(\"access_token\").await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.refreshAccessToken(\"accessToken\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport ETOPaySdk\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.refreshAccessToken(access_token: \"access_token\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.refreshAccessToken(\"access_token\");\n</code></pre> <p>Warning</p> <p>The SDK is not responsible for refreshing the access token. Neither does it have the credentials, nor a way to obtain credentials for refreshing an access token for the user. This is the responsibility of the client application integrating the SDK. The refresh_access_token function should not be confused with refresh_token and should not be passed the value of refresh_token. The function needs the value of a valid access_token as a string.</p>"},{"location":"SDK%20Configuration/Configuration/#configuring-the-backend","title":"Configuring the backend","text":"<p>The ETOPay team provides the URL for the backend, which is specified as the<code>backend_url</code> field of the configuration. This information is part of the initial setup and is important before starting the SDK usage.</p>"},{"location":"SDK%20Configuration/Configuration/#configuring-the-storage-path-prefix","title":"Configuring the storage path prefix","text":"<p>For all platforms, except for when using the TypeScript/Javascript bindings, it is mandatory that the application has access to a file system where it is allowed read and write files and directories and sub-directories. This (existing) folder is specified as the <code>strorage_path</code> field in the configuration and accepts both releative and absolute paths. Absolute paths are, however, preferred and recommended.</p> Tip <p>It is recommended to use a path where only the application has file system rights. Allowing access to other applications is a potential security risk and may incur loss of funds for end-users.</p> Tip <p>For use in Android applications, it is important to extract the path where the app has permissions to create files and directories and use it as the storage path. This is generally something like <code>\\data\\data\\org.example.app\\</code> if the application package is <code>org.example.app</code>.</p>"},{"location":"SDK%20Configuration/Configuration/#logging-in-the-sdk-and-validating-configuration","title":"Logging in the SDK and validating configuration","text":"<p>Whenever the SDK is configured, the logger is automatically initialized. For all platforms except TypeScript/Javascript, whenever a valid log level is specified in the <code>log_level</code> field, the logger is initialized to append log messages to a <code>etopay_sdk.log</code> file in the specified <code>storage_path</code> folder. The different log levels that can be set for the logger are: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> and allow for fine-tuning the amount of log messages that are generated. A value of <code>off</code> can also be specified to disable logging completely. It is important and recommended to enable the logger since this information can be exported and analyzed during testing and integration, which can help diagnose any issues.</p>"},{"location":"SDK%20Configuration/Configuration/#complete-example","title":"Complete example","text":"<p>For a complete example of how to setup and configure the SDK before using any of its module functions, please see Example 0. Shared Setup Code.</p> <ol> <li> <p>The following information links could be used as reference for OAuth2.0 and OpenID Connect</p> <p>OAuth 2.0 Official Website</p> <p>OAuth 2.0 RFC</p> <p>OAuth 2.0 Simplified</p> <p>OAuth 2.0 Playground</p> <p>OpenID Connect Official Website</p> <p>OpenID Connect RFC</p> <p>OpenID Connect Playground</p> <p>OpenID Connect Introduction \u21a9</p> </li> </ol>"},{"location":"SDK%20Examples/Examples/","title":"Examples","text":"<p>The ETOPay SDK is built in <code>rust</code>. It is primarily an implementation of the various interfaces for managing users, wallets, on-boarding of users through KYC (Know Your Customer) processes, payment methods and listing usage information. The flows discussed in this document show examples using the rust language. For examples related to the specific language, refer to the corresponding pages.</p> <p>The ETOPay SDK can be used only if the following pre-requisites have been fulfilled and the information resulting from these conditions is available:</p> <ul> <li>Oauth2.0 Identity and Access Management Provider is configured correctly,</li> <li>The backend base URL of the ETOPay system is known,</li> <li>The path to a certain file storage is available, where the application has read/write rights to create, modify and delete files related to the SDK like log files, local key-value DBs, and wallet files.</li> </ul> <p>Once this information is available, the SDK can be instantiated and the basic functions can be used.</p> <p>The examples shows the usage of the SDK in rust for creating a user. The user credentials are taken from the environment but could also be easily a user input.</p> <p>The environment configuration to <code>Development</code> attaches the SDK to the development backend of ETOPay automatically. It also configures the authentication provider correctly with the one used by the development team internally. This configuration is used by ETOPay developers and is only restricted to the users controlled by the identity provider configured for ETOPay internal testing.</p>"},{"location":"SDK%20Examples/Examples/#0-shared-setup-code","title":"0. Shared Setup Code","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#1-create-new-user","title":"1. Create New User","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#2-onboard-user-postident","title":"2. Onboard User Postident","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#4-migrate-wallet-from-mnemonic","title":"4. Migrate Wallet From Mnemonic","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#5-migrate-wallet-from-backup","title":"5. Migrate Wallet From Backup","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#6-generate-new-receiver-address","title":"6. Generate New Receiver Address","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#7-get-balance","title":"7. Get Balance","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#8-create-purchase-request","title":"8. Create Purchase Request","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#9-onboard-a-user-on-viviswap","title":"9. Onboard a User on Viviswap","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#10-verify-pin","title":"10. Verify Pin","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#11-reset-pin","title":"11. Reset Pin","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#12-change-password","title":"12. Change Password","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#13-send-amount","title":"13. Send Amount","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#14-get-exchange-rate","title":"14. Get Exchange Rate","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#16-get-purchase-list","title":"16. Get Purchase List","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#18-delete-user","title":"18. Delete User","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#19-get-wallet-transaction-list","title":"19. Get Wallet Transaction List","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#20-send-compliment","title":"20. Send Compliment","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#22-initialize-wallet-from-shares","title":"22. Initialize Wallet from Shares","text":"Rust"},{"location":"SDK%20Modules/Managing%20user/","title":"User management","text":"<p>The SDK is designed to allow multiple users working with their own wallets on the same end devices sharing the same storage space. This makes it easy for a single person to have multiple alias users for different purposes and use different wallets for each of them to have a clear separation of risks.</p> <p>The user initialization is done by two main operations in the SDK.</p> <p>Creating a new user : This creates a new user in the in-memory database. All the properties of the user, like his selected KYC process, his KYC status, his access token for the backend, pin, encrypted password, etc... are set with the default values. A salt is generated for the user, which will be used later for encrypting the password.</p> <p>Initializing a user : This function initializes the user for a new session. It also checks that a valid access token has been provided by updating the KYC status of the user from the backend in the SDK internal state.</p>"},{"location":"SDK%20Modules/Managing%20user/#creating-a-new-user","title":"Creating a new user","text":"<p>User creation in the SDK is compulsory. This user is only a local user which might be already existing in the identity management provider.  </p> Note <p>The user might already exist in the OAuth system, as well as every where else, including ETOPay backend. However, the SDK associates the local user to the system user only when an access token is provided.</p> <p>The SDK supports multi-user environments and switching between users is fairly simple. Creating a user in the SDK informs the SDK about the user and allows the SDK to manage the user's state locally, whilst syncing it with the backend periodically.</p> <p>This allows the SDK to be used across multiple devices, and ideally on the same device, on multiple storage path prefixes. This means, that changing the storage path prefix would result in the SDK unknowing the existence of the user and would require to create the user once again.</p> <p>Creating a new user can be done using the <code>create_new_user</code> function which takes the <code>username</code> input parameter. Before creating a user, it is important that at least the storage path is set in the SDK.</p> <p>The <code>username</code> should always match the <code>preferred_username</code> claim on the JWT <code>access_token</code>, otherwise the SDK would not be able to access the backend services for that user. Through this, the newly created SDK local user gets recognized in the system as a valid user.</p> Tip <p>The application can extract the <code>preferred_username</code> information automatically from the JWT claim and set the username directly, instead of asking the user to enter the input. A user might mistype or misunderstand and enter a username which might later not work. This would lead to a bad end-user experience and should be avoided.</p> <p>Note</p> <p>The code snippets provided are intended as pseudo-code to demonstrate logic and workflows. They are not guaranteed to compile, execute, or function as-is. Users should adapt and validate them according to their specific requirements and development environment.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    sdk.create_new_user(\"username\").await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.createNewUser(\"username\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport ETOPaySdk\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.createNewUser(username: \"username\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.createNewUser(\"username\");\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#initializing-a-user-and-access-token-refresh","title":"Initializing a user and access token refresh","text":"<p>The user is created and needs to be initialized before any state updates or wallet-related operations can be performed for this user. This allows the SDK to create multiple users and by using the initializing function, only the selected user is activated for the session. Without initializing a user, all operations related to the user would fail or conversely the previously initialized user's session will be used and might corrupt the state! To protect this from happening, before initializing the user, a corresponding access token is required. An invalid access token would result in failure of the initialization.</p> <p>The access token brings the following safe operations for the SDK:</p> <ol> <li>Only the correct user with the username would be initialized. Mismatch would cause an error.</li> <li>The application can only initialize a user, only after the authorization of the actual person, since they would need to share their credentials for creating an access token.</li> <li>Any user whose rights have been revoked, due to misuse reports, would not be able to use the system as the access token would be invalid and generating a new one would not also work.</li> </ol> <p>Warning</p> <p>The user management is local to the end devices and deleting the application data, cache, temporary data files, etc... or changing the storage path prefix in the configuration would result in a loss of state and that would require the application to re-create and re-initialize user.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    sdk.create_new_user(\"username\").await.unwrap();\n\n    sdk.refresh_access_token(\"access_token\").await.unwrap();\n    sdk.init_user(\"username\").await.unwrap();\n\n    // other SDK functions now use the initialized user\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.createNewUser(\"username\");\n            sdk.refreshAccessToken(\"accessToken\");\n            sdk.initializeUser(\"username\");\n            // other SDK functions now use the initialized user\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport ETOPaySdk\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.createNewUser(username: \"username\")\n    try await sdk.refreshAccessToken(access_token: \"access_token\")\n    try await sdk.initUser(username: \"username\")\n    // other SDK functions now use the initialized user\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.createNewUser(\"username\");\nawait sdk.refreshAccessToken(\"access_token\");\nawait sdk.initializeUser(\"username\");\n// other SDK functions now use the initialized user\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#deleting-a-user","title":"Deleting a user","text":"<p>Deleting the user is simply deleting the user entity from the local database, while maintaining entries for other users. The delete user also calls the backend API to trigger an archiving action for the user. Deleting the user also deletes all the local data files for the user, which in this case are files related to the wallet. Since, this is a one-way operation a user is required to enter the pin, that they have set for the wallet. If there is no wallet setup, the pin can be skipped and the user is simply deleted locally and archived in the backend.</p> <p>Danger</p> <p>Deleting a user not only deletes the user in the system but also deletes all local files and information from the device. This means, that the wallet is also deleted. Hence, a pin is used to verify if the user wishes to delete all this information. Deletion of a wallet without having a backup file or without the mnemonic is extremely dangerous as it can potentially lead to permanent loss of funds.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    sdk.create_new_user(\"username\").await.unwrap();\n    sdk.refresh_access_token(\"access_token\").await.unwrap();\n    sdk.init_user(\"username\").await.unwrap();\n\n    let pin = \"1234\"; \n    // only if wallet was created by the user, a pin value is required.\n    // otherwise, it is None.\n    sdk.delete_user(Some(pin)).await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.createNewUser(\"username\");\n\n            sdk.refreshAccessToken(\"accessToken\");\n            sdk.initializeUser(\"username\");\n\n            String pin = \"1234\"; \n            // only if wallet was created by the user, a pin value is required.\n            // otherwise, it is null.\n            sdk.deleteUser(pin)\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport ETOPaySdk\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.createNewUser(username: \"username\")\n\n    try await sdk.refreshAccessToken(access_token: \"access_token\")\n    try await sdk.initUser(username: \"username\")\n\n    let pin = \"1234\"; \n    // only if wallet was created by the user, a pin value is required.\n    // otherwise, it is nil.\n    try await sdk.deleteUser(pin: pin)\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.createNewUser(\"username\");\nawait sdk.refreshAccessToken(\"access_token\");\nawait sdk.initializeUser(\"username\");\n\nlet pin = \"1234\"; \n// only if wallet was created by the user, a pin value is required.\n// otherwise, it is null.\nawait sdk.deleteUser(pin);\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#user-lifecycle-overview","title":"User lifecycle overview","text":"<pre><code>      Username    Refresh access   Username              Pin              \n         |            token          |                      |             \n         |             |             |                      |             \n         |             |             |                      |             \n         |             |             |                      |             \n    +----v---------+   |     +-------v------+        +------v---------+   \n    |              |   |     |              |        |                |   \n    |  Create      |   |     | Initialize   |        |     Delete     |   \n    |  new         +---v-----&gt; User         +--------&gt;     User       |   \n    |  User        |         |              |        |                |   \n    +--------------+         +-----+--------+        +----------------+   \nOnce                                |\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nMultiple                            |\nTimes                   +-----------v-----------------+\n                        |  User           Wallet      |\n                        |  State          Operations  |\n                        |  Change                     |\n                        +-----------------------------+\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/","title":"Wallet management","text":"<p>The SDK provides users with the opportunity to host their own wallets on their personal end-devices in a safe and easy manner. Before discussing wallet management, some information on wallets and what they are is needed to understand how to manage non-custodial hot wallets.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#the-iota-wallet","title":"The IOTA wallet","text":"<p>The wallet used within the SDK is the official wallet developed by the IOTA Foundation and maintained in its own SDK found here. The wallet internally uses the stronghold secret management engine also developed by the IOTA Foundation found here. The secret management engine not only stores sensitive data in files but also uses obfuscation and mechanisms against memory dumps to protect the secrets while they are being operated upon in the memory. Stronghold also provides functions for BIP-0032 derivation using the BIP-0044 derivation path mechanism described here. The word list used by the wallet is the word list described in BIP-0039 here.</p> <p>The various coin types supported by BIP-0044 can be found in the list here. Both <code>IOTA</code> and <code>SMR</code> are supported and have the coin types <code>4218</code> and <code>4219</code> respectively.</p> <p>Currently, in its base implementation the IOTA SDK also needs an in-memory key-value store to manage some metadata related to the stronghold engine and other wallet settings. The IOTA SDK uses a rocksdb implementation in rust for this purpose. There are a few noteworthy problems with rocksdb:</p> <ul> <li>rocksdb is not light-weight for mobile end devices and the resulting binaries of the sdk take long to build and are bigger in storage requirements.</li> <li>rocksdb does not support all mobile platforms</li> <li>rocksdb is not maintained on the latest sdks of the android and iOS mobile platforms</li> </ul> <p>After investigation, it was found that the in-memory key-value store was used only for storing some metadata keys and not necessarily need high-performance query execution. Luckily, the IOTA SDK implemented the rocksdb connection as a <code>Storage</code> trait. Since, the SDK already used jammdb for its internal key-value store, a fork was created and the trait was implemented using <code>jammdb</code>. A pull request was created to the upstream, but the dev team at IOTA Foundation recommended to maintain the fork for now, as there would be some new breaking changes coming and the pull request can be created at a later point. The fork is updated regularly and maintained here.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#hot-wallets-the-swift-side-of-crypto","title":"Hot Wallets: The Swift Side of Crypto","text":"<p>Picture a hot wallet as the bustling city centre of your digital finances. Hot wallets are online, connected to the internet, and readily available for transactions. They provide users with quick access to their cryptocurrencies, making them ideal for active trading and daily transactions. Think of them as your go-to pocket wallet for everyday spending in the digital realm.</p> <p>However, convenience comes at a cost. The very connectivity that makes hot wallets user-friendly also renders them more vulnerable to cyber threats. Hacking attempts and online attacks pose a constant risk, making it crucial for users to exercise caution and implement additional security measures when relying on hot wallets.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#pin-and-password-in-the-sdk","title":"Pin and password in the SDK","text":"<p>Generally, the password requirements for any application need to meet today's standards. This might become difficult for the user to remember their wallet stronghold password and also an irritating experience to enter it every time even for the smallest of transactions. On the other side, for a secure wallet application, the SDK should not rely on the interfacing application to do password management for a secret manager used internally. This has a lot of side effects, such as, the application might bypass the SDK logic for protecting access to the secret by simply using the password against the file, with no knowledge of the SDK. This is a security risk and cannot be accepted.</p> <p>The end devices today support pin entry mostly protected by biometric authentication for ease but secure user experience, when it comes to accessing a restricted OS functionality. Taking all this in account, the SDK was designed to provide the end users possibilities to set up their wallet using a <code>password</code> and a <code>pin</code>.</p> <ul> <li> <p>The password stays with the SDK in an encrypted form and only the pin can be used to decrypt it. Thus, for every operation with the secret manager, where a password is needed, the user must only enter the pin. This solves the problem of user experience.</p> </li> <li> <p>The issue of password management is also solved, since now the SDK internally manages the password, while still relying completely on the user to unblock it using the pin. The SDK cannot act in its own interest even if there was a malicious code trying to unblock the wallet! The probability distribution of the pin, being relatively weak, (4 to 6 digit), is improved through the addition of a pseudo random salt, which in combination with a hash function results in an encryption password of significant strength and quasi-random probability distribution. This is used then to encrypt the password for the secret manager.</p> </li> </ul> <p>Thus an attacker would need information on the salt, the encrypted password, pin and the stronghold file to be able to gain access to the wallet functions. This is tough and would need somehow physical access to the end device, and to the end user. Security of end-user and their devices is out of the scope for ETOPay ecosystem.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#creating-the-wallet","title":"Creating the wallet","text":"<p>The stronghold secret manager requires a file path for the wallet and a password to unlock this file. This password disables other applications from interpreting the files created by the stronghold engine and needs to come from the user.</p> <p>The IOTA SDK offers an account manager structure which comprises of various fields to work with the wallet and the internal wallet accounts. The SDK creates a standard account <code>standalone</code> for its usage. There might be other accounts that could exist and are not operated upon by the SDK. The following ways can be used to create a wallet in the SDK:</p>"},{"location":"SDK%20Modules/Managing%20wallet/#create-a-new-wallet","title":"Create a new wallet","text":"<p>This does not require any user input except <code>username</code>,  <code>password</code> and <code>pin</code>. But, this should be a multi-step process. The created wallet returns a mnemonic. The app should immediately delete the wallet. In the second step the migration of the wallet with the mnemonic should be carried out and the wallet is only loaded with the mnemonic entered by the user. This approach protects the user against creating a wallet without never confirming the mnemonic back to the SDK and also by deleting a wallet, the SDK can ensure that there is actually no wallet created whose mnemonic was never entered from outside the application. This forces applications to have their end-users the mnemonic either memorized or input from a copy.</p> Info <p>A fresh wallet can be created by a random seed, using the stronghold secret manager. It needs the password and username. The username is part of the file path and helps distinguish across different user wallets on the same end device. It returns the mnemonic, and this needs to be securely stored by the user, otherwise access to the funds on the wallet addresses would get limited. A node url for the DLT network can also be selected. Currently, the PoW is set to local, however it might change based on the used node url and its support for PoW.</p> <p>Note</p> <p>The code snippets provided are intended as pseudo-code to demonstrate logic and workflows. They are not guaranteed to compile, execute, or function as-is. Users should adapt and validate them according to their specific requirements and development environment.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize the user\n\n    let mnemonic = sdk.create_new_wallet(\"pin\", \"password\").await.unwrap();\n    sdk.verify_mnemonic(\"pin\", \"password\", &amp;mnemonic).await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize the user\n\n        try {\n            String mnemonic = sdk.createNewWallet(\"pin\", \"password\");\n            sdk.verifyMnemonic(\"pin\", \"password\", mnemonic); \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import ETOPaySdk\nimport Foundation\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize the user\n\ndo {\n    mnemonic = try await sdk.createNewWallet(pin: \"pin\", password: \"password\")\n    try await sdk.verifyMnemonic(pin: \"pin\", password: \"password\", mnemonic: mnemonic)\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n\nawait sdk.setWalletPassword(\"pin\", \"password\");\nlet mnemonic = await sdk.createNewWallet(\"pin\");\nawait sdk.verifyMnemonic(\"pin\", mnemonic)\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#migrate-an-existing-wallet","title":"Migrate an existing wallet","text":"<p>This just performs the second step of the create fresh wallet process and needs in addition to the <code>mnemonic</code> also the <code>username</code>, <code>password</code> and <code>pin</code>.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize the user\n\n    sdk.create_wallet_from_mnemonic(\"pin\", \"password\", \"mnemonic\").await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize the user\n\n        try {\n            sdk.createWalletFromMnemonic(\"pin\", \"password\", \"mnemonic\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import ETOPaySdk\nimport Foundation\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize the user\n\ndo {\n    try await sdk.createWalletFromMnemonic(pin: \"pin\", password: \"password\", mnemonic: \"mnemonic\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n\nawait sdk.setWalletPassword(\"pin\", \"password\");\nawait sdk.createWalletFromMnemonic(\"pin\", \"mnemonic\");\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#create-wallet-from-a-backup-file","title":"Create wallet from a backup file","text":"<p>The SDK provides functionality to create a backup file in <code>kdbx</code> format as a byte array. Backups can only be created if a wallet exists.</p> <p>To create the backup, the following are required:</p> <ul> <li><code>pin</code>: This is the same PIN that was set for the wallet.</li> <li><code>backup_password</code>: A new, separate password set specifically for securing the backup file. This is not the same password used for the wallet.</li> </ul> <p>To restore the backup, the following are required:</p> <ul> <li>The kdbx <code>backup bytes</code>.</li> <li>A <code>new pin</code> used to create the new wallet.</li> <li>The <code>backup_password</code> used during the backup process.</li> </ul> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize the user\n\n    let backup_bytes: Vec&lt;u8&gt; = sdk.create_wallet_backup(\"pin\", \"backup_password\").await.unwrap();\n    sdk.create_wallet_from_backup(\"new pin\", &amp;backup_bytes, \"backup_password\").await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize the user\n\n        try {\n            byte[] backup_bytes = sdk.createWalletBackup(\"pin\", \"backup_password\");\n            sdk.createWalletFromBackup(\"new pin\", backup_bytes, \"backup_password\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import ETOPaySdk\nimport Foundation\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize the user\n\ndo {\n    let backup_bytes = try await sdk.createWalletBackup(pin: \"pin\", password: \"backup_path\")\n    try await sdk.restoreWalletFromBackup(pin: \"new pin\", backup: backup_bytes, backup_password: \"backup_password\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n\nlet backup_bytes = await sdk.createWalletBackup(\"pin\", \"backup_password\");\nawait sdk.createWalletFromBackup(\"new pin\", backup_bytes, \"backup_password\");\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#deleting-the-wallet","title":"Deleting the wallet","text":"<p>This function just deletes the wallet files and is a one-way function, to be used under extreme caution, as it could result in permanent loss of funds. Note that, similar to any other wallet operation, deleting the wallet is also a wallet operation and requires the wallet to be correctly initialized. Without initialization, the deletion of wallet would fail.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize new user\n    // Create a new wallet\n\n    sdk.delete_wallet();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize new user\n        // Create a new wallet\n\n        try {\n            sdk.deleteWallet();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import ETOPaySdk\nimport Foundation\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize new user\n// Create a new wallet\n\ndo {\n    try await sdk.deleteWallet()\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n// Create a new wallet\n\nawait sdk.deleteWallet(\"pin\")\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#password-and-pin-utilities","title":"Password and pin utilities","text":"<p>In addition to creating, migrating, backups and initialization, the wallet module also performs auxiliary operations for pin and password management. It supports function to reset the pin using password, verify the pin, or change the wallet password using the current password and pin. Wallet initialization is again a pre-requisite, since the pin and password operations are related to the wallet and can only be performed once a wallet is initialized successfully.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize new user\n    // Create a new wallet\n\n    // Try to verify the pin\n    sdk.verify_pin(\"pin\");\n    // or reset the pin to a new one\n    sdk.reset_pin(\"password\", \"new_pin\")\n    // or change the password\n    sdk.change_password(\"pin\", \"password\", \"new_password\");\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize new user\n        // Create a new wallet\n\n        try {\n            // Try to verify the pin\n            sdk.pinVerify(\"pin\");\n            // or reset the pin to a new one\n            sdk.pinReset(\"password\", \"new_pin\");\n            // or change the password\n            sdk.passwordChange(\"pin\", \"password\", \"new_password\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import ETOPaySdk\nimport Foundation\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize new user\n// Create a new wallet\n\ndo {\n    // Try to verify the pin\n    try await sdk.verifyPin(pin: \"pin\")\n    // or reset the pin to a new one\n    try await sdk.resetPin(password: \"password\", new_pin: \"new_pin\")\n    // or change the password\n    try await sdk.changePassword(pin: \"pin\", current_password: \"password\", new_password: \"new_password\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n// Create a new wallet\n\n// Try to verify the pin\nawait sdk.verifyPin(\"pin\");\n// or reset the pin to a new one\nawait sdk.resetPin(\"pin\", \"new_pin\");\n// or change the password\nawait sdk.setWalletPassword(\"pin\", \"new_password\");\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#wallet-flows","title":"Wallet flows","text":"<pre><code>                Mnemonic  Username  Password  Pin  backup password         Pin                            Pin        \n                   | ^         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n    Inputs         v |         v      v       v      v                     v                              v          \n-------------------------------------------------------------------------------------------------------------------  \n                                                                |                           |                        \n                                           +-------------+      |                           |                        \n                                           |             |      |                           |                        \n                                           | Create      |      |      +-------------+      |                        \n                                           | New         +---+  |      |             |      |        +--------------+\n                                           | Wallet      |   |  |      |  Initialize |      |        |              |\n                                           |             |   |  |      |  Wallet     +------+--------&gt;   Delete     |\n                                           +-------------+   |  +------&gt;             |      |        |   wallet     |\n                                                             |  |      |             |      |        |   (external) |\n                                                             |  |      +------+------+      |        |              |\n                         +----------+      +-------------+   |  |             |             |        +--------------+\n                         |          |      |             |   |  |             |             |                        \n                         | Mnemonic |      | Migrate     |   |  |             |             |                        \n                 +-------&gt;          +------&gt; Existing    |   |  |             |             |                        \n                 |       |          |      | Wallet      |   |  |      +------v------+      |                        \n                 |       |          |      |             |   |  |      |             |      |                        \n                 |       +----------+      +-------------+   |  |      |  User       |      |                        \n                 |                                           |  |      |  Wallet     |      |                        \n                 |                                           |  |      |  Functions  |      |                        \n                 |           +------+      +-------------+   |  |      |             |      |                        \n                 |           |      |      |             |   |  |      +-------------+      |                        \n                 |           |Backup|      | Create      |   |  |                           |                        \n                 |           | File +------&gt; Wallet      |   |  |                           |                        \n                 |           |      |      | From        |   |  |                           |                        \n                 |           |      |      | Backup      |   |  |                           |                        \n                 |           +------+      +-------------+   |  |                           |                        \n                 |                                           |  |                           |                        \n                 |                                           |  |                           |                        \n                 |    +-------------+      +-------------+   |  |                           |                        \n                 |    |             |      |             |   |  |                           |                        \n                 |    | Verify      |      |  Delete     |   |  |                           |                        \n                 +----+ Mnemonic    &lt;------+  wallet     &lt;---+  |                           |                        \n                      |             |      | (internal)  |      |                           |                        \n                      |             |      |             |      |                           |                        \n                      +-------------+      +-------------+      |                           |                        \n                                                                |                           |                        \n                                                                |                           |                        \n                                             Once(setup)        |        Multiple times     |       Once (tear down) \n                                                                |                           |                        \n</code></pre>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/","title":"Transactions, Swaps and Purchases","text":"<p>The SDK is primarily used to perform transactions. The type of transactions that the SDK currently facilitates are</p> <ol> <li>Wallet transactions</li> <li>Swap transactions</li> <li>Purchase transactions</li> </ol>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#wallet-transactions-flow","title":"Wallet transactions flow","text":"<pre><code>+---------------+                      +---------------+\n|               |                      |               |\n|               |                      | Wallet        |\n| Wallet        +----------------------&gt; Address       |\n| Address       |                      | Receiver      |\n| Sender        |                      |               |\n+---------------+                      +---------------+\n</code></pre> <p>The wallet transaction is a simple transfer of funds from one address to another facilitated by the DLT network node and the wallet software running within the SDK.</p>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#swap-transactions-flow","title":"Swap transactions flow","text":"<p>A swap is simply an exchange of value from one currency to another. In the current scenario, the swap is always between SMR &lt;--&gt; EURO currencies. This is executed at viviswap exchange.</p> <p>For payments in EURO, only the SEPA transfer method is currently supported. See the german explanation here and the english explanation here</p> <p>The EURO payment needs the user to setup and add their IBAN (International Bank Account Number) to the viviswap exchange. Through this, the viviswap uses SEPA transfers to this IBAN, whenever a swap is triggered from SMR to EURO. The other way around, currently, since direct debit is not setup from the bank of viviswap, the user has to transfer manually from exactly this IBAN (viviswap verifies it in every transfer) to the IBAN owned by viviswap with the amount and a reference number provided by viviswap.</p> <ol> <li><code>get_iban_for_viviswap</code>: This function allows the user query their own IBAN saved at viviswap.</li> <li><code>ensure_detail</code>: This function verifies if a detail created at viviswap is legitimate, syntactically and semantically. A detail is basically an address for a particular payment method. The various payment methods used by viviswap are SMR, IOTA, BTC, ETH, etc... for crypto-currencies and PAYPAL, SEPA, etc... for EURO payments. For example, the address for the payment method SMR would be shimmer wallet address and the address for the payment method SEPA would be the IBAN.</li> <li><code>update_iban_for_viviswap</code>: This function updates the IBAN of the user in the viviswap exchange. The update is actually an advanced <code>upsert</code> action. The update would insert the IBAN if none exists and also replace the existing IBAN with the new one.</li> <li><code>create_deposit_with_viviswap</code>: This function creates details of a fiat to crypto swap. Deposit is to be understood as deposit of funds to a crypto currency address. Currently, the swap is between EURO to SMR. Since, there is no direct debit authorization available, creating the deposit generally means getting information about the bank details of viviswap and the reference number, and advising the user to make a SEPA transfer in the required amount.</li> <li><code>create_detail_for_viviswap</code>: This function creates a user detail for a payment method. This could be adding the crypto address for a certain payment method to the viviswap exchange. This detail with its id can then be directly used for the swaps.</li> <li><code>get_payment_method_id_viviswap</code>: This is a generic function and has to be called once to cache the UUIDs of all the payment methods supported by viviswap.</li> <li><code>create_withdrawal_with_viviswap</code>: This function is the opposite of deposit. Withdrawal is to be understood as withdrawal of funds from a crypto currency address. If a pin is provided, the function automatically immediately transfers money from the crypto address of the user to that of viviswap and ideally viviswap would automatically transfer the funds to the IBAN created in their system. If no pin is provided, the user is shown the crypto address of the chosen payment method and the user can decide to transfer the funds to this address at any point.</li> <li><code>get_swap_list</code>: This function gives the list of swaps performed at viviswap.</li> <li><code>get_swap_details</code>: This function gives details about a swap, like information on fees, exchange rate, the swap status, etc...</li> <li><code>get_exchange_rate</code>: This function provides the exchange rate for the involved currencies in the swap. Currently, the exchange rate is always provided with EURO as base currency, i.e. it is either SMR/EURO or IOTA/EUR or BTC/EURO and so on... An inversion of the exchange rate gives the reverse rate and should be calculated by simply inverting the value. As confirmed by viviswap, there are no vertical spreads to be considered here!</li> </ol> <pre><code>                              Deposit Flow                        \n\n\n            +------------+            |          +------------+   \n            |            |            |          |            |   \n            | User       |            |          | Viviswap   |   \n            | Wallet     &lt;------------+----------+ Wallet     |   \n            | Address    |            |          | Address    |   \n            |            |            |          |            |   \n            +------------+            |          +------^-----+   \n                                      |                 |         \n                                      |                 |         \n                                      |                 |         \n                                      |                 |Trigger  \n                                      |                 |         \n                                      |                 |         \n                                      |                 |         \n            +------------+            |            +----+-------+ \n            |            |            |            |            | \nUser        | User       |     Bank   |            |  Viviswap  | \n------------&gt; IBAN       +------------+------------&gt;  IBAN      | \nAction      |            |     Ref.   |            |            | \n            |            |     Nr.    |            |            | \n            +------^-----+            |            +------------+ \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |             +------------+\n                   +------------------+-------------+            |\n                                      |             |  Create    |\n           Update  -------------------+-------------&gt;  Deposit   |\n           User           Payment     |             |  Detail    |\n           IBAN           Detail      |             |            |\n                                      |             +------------+\n                                      |                           \n                                      |                           \n                              User    |    Viviswap               \n</code></pre> <pre><code>                 Withdraw Flow                       \n\n                                   +------------+    \n                                   |            |    \n  User                    |        |  Create    |    \n  ------------------------+--------&gt;  Withdraw  |    \n  Action                  |        |  Detail    |    \n              Viviswap    |        |            |    \n      +-------------------+--------+------------+    \n      |       Address     |                          \n      |                   |                          \n+-----v------+            |          +------------+  \n|            |            |          |            |  \n| User       |            |          | Viviswap   |  \n| Wallet     +------------+----------&gt; Wallet     |  \n| Address    |            |          | Address    |  \n|            |            |          |            |  \n+------------+            |          +------+-----+  \n                          |                 |        \n                          |                 |        \n                          |                 |        \n                          |                 |Trigger \n                          |                 |        \n                          |                 |        \n                          |                 |        \n+------------+            |            +----v-------+\n|            |            |            |            |\n| User       |            |            |  Viviswap  |\n| IBAN       &lt;------------+------------+  IBAN      |\n|            |            |            |            |\n|            |            |            |            |\n+------------+            |            +------------+\n                          |                          \n                          |                          \n                          |                          \n                  User    |    Viviswap              \n</code></pre>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#purchase-transactions-flow","title":"Purchase transactions flow","text":"<p>The purchase transaction is a process different than a swap or a wallet transaction. The purchase is a process of exchanging funds for an underlying artefact. An artefact can be something promised between two parties like a photo, video, or a compliment on a photo, sensor data, services, licenses, etc... The SDK is only interested in creation, querying and confirmation of these purchase requests. The rest of the business logic flow is handled by the corresponding service in ETOPay infrastructure. The transfer of artefact can happen only after a successful execution of the purchase request. This information can be verified at all times by querying the status of the purchase request and the details of the purchase request.</p> <p>A purchase request can be created at any time and is unique per purchase. A purchase id is returned by the infrastructure to track this particular request. Currently, polling is used to wait for the purchase request to be valid. It can be invalid for multiple reasons, as defined in the infrastructure. In case the request turns out to be valid, then the details (supplemented by the infrastructure) are fetched and a confirmation is done through the sdk.</p> <p>The confirmation of a purchase request means that funds are required to be released from the wallet and this operation needs the pin from the user, to avoid creation and confirmation of purchase request which might not have been authorized by the user. The confirmation triggers a wallet transaction to the recipient's wallet address as well as to the system's wallet address. The purchase details deliver this information for each individual purchase request. The result of the wallet transaction is then added to the purchase request and sent to the infrastructure as part of the confirmation body, so that the infrastructure can search for the transaction on the DLT network.</p> <pre><code>                                        |                      \n                                        |                      \n                                        |                      \n                 +-------------+        |                      \n                 |             |        |                      \n       User      | Create      |        |                      \n     +-----------&gt; Purchase    +--------+-+     +-------------+\n     | Request   | Request     |        | |     |             |\n     |           |             |        | |     |  (Polling)  |\n     |           +-------------+        | +-----&gt;  Get        |\n     |                                  |       |  Purchase   |\n     |                                  |       |  Status     |\n     |                                  |       +------+------+\n     |      Pin                         |              |       \n     +-------------------+              |              |Valid  \n                         |              |              |       \n                         |              |       +------v------+\n                  +------v------+       |       |             |\n                  |             |       |       |  Get        |\n    Wallet        | Confirm     &lt;-------+-------+  Purchase   |\n&lt;-----------------+ Purchase    |       |       |  Details    |\n    Transaction   | Request     |       |       |             |\n                  |             |       |       +-------------+\n                  +-------------+       |                      \n                                        |                      \n                                        |                      \n                                        |                      \n                                        |                      \n                               Once     |   Multiple times     \n                                        |                      \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/","title":"API Reference","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#levels-and-repeats","title":"Levels and Repeats","text":"Category Description Levels Basic The functions at these levels are absolutely necessary to use the SDK. Without calling these functions, the SDK is never in a correct state. Optional functions can be skipped, since they will take default values, if that is the requirement. Usage The functions at these levels can only be called once all basic level functions have successfully executed. Repeats Handle The functions need to be called every time a new SDK Handle (object) needs to be created via a constructor or after garbage collection of any existing old handles. User The functions need to be called every time a new SDK user needs to be created. Application The functions can be called any time while using the SDK, however they may fail, if the certain dependencies are not fulfilled."},{"location":"SDK%20Reference/SDK%20API%20Reference/#usage-infos-and-warnings","title":"Usage infos and warnings","text":"<p>Warning</p> <ul> <li>Viviswap and Postident KYC onboarding will not work if the user is already kyc verified.</li> <li>KYC onboarding with another provider will not work if the user is already started kyc onboarding with one of the other providers.</li> <li>Restoring a wallet backup may fail, if the wallet is already existing.</li> <li>Initializing User and initializing wallet may fail, if the user and wallet are already initialized. Since, there is no de-init function, the  SDK handle needs to be closed, or a new handle needs to be created to re init. </li> <li>Multiple handles to the wallet may also fail, since only atomic access are allowed.</li> <li>Deleting a user may fail if the backend cannot be reached.</li> </ul>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#javascript-typescript","title":"JavaScript / TypeScript","text":"<p>The API reference for the JS/TS bindings are available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#java","title":"Java","text":"<p>The Javadoc API reference for the Java bindings is available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#rust","title":"Rust","text":"<p>The Rustdoc API reference is available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#sdk-initialization-and-configuration","title":"SDK Initialization and Configuration","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#instantiating-the-sdk","title":"Instantiating the SDK","text":"Method Arguments Returns Dependencies Level Repeat Constructor Returns an <code>Error</code> if there is an issue in loading the dynamically or statically linked binary shared library, otherwise the handle to the SDK Basic Handle RustJavaTypescriptSwift <p>constructor</p> <p>constructor</p> <p>constructor</p> <p>Not available yet!</p> <pre><code>import ETOPaySdk\nlet sdk = ETOPaySdk()\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-configuration","title":"Set configuration","text":"Method Arguments Returns Dependencies Level Repeat Set the SDK configuration parameters. <code>config</code> - The JSON formatted string containing the configuration parameters. See SDK Configuration for more information of the available options. Constructor Basic Handle RustJavaTypescriptSwift <p>set_config</p> <p>setConfig</p> <p>setConfig</p> <p>Not available yet!</p> <pre><code>public func setConfig(config: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-supported-networks","title":"Get supported networks","text":"Method Arguments Returns Dependencies Level Repeat Get the supported networks. Returns a list of ApiNetwork. Constructor, Set Configuration, Refresh access token, User initialization Basic RustJavaTypescriptSwift <p>getNetworks</p> <p>getNetworks</p> <p>getNetworks</p> <p>Not available yet!</p> <pre><code>public func getNetworks() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-network","title":"Set network","text":"Method Arguments Returns Dependencies Level Repeat Sets the network <code>network_id</code> - The network_id as string. Constructor Basic Handle RustJavaTypescriptSwift <p>set_network</p> <p>setNetwork</p> <p>setNetwork</p> <p>Not available yet!</p> <pre><code>public func setNetwork(network_id: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-build-information","title":"Get build information","text":"Method Arguments Returns Dependencies Level Repeat Get the SDK build information Returns a multi-line String containing: <code>Branch name</code> (e.g. main), <code>Commit hash</code> (e.g. 92cedead), <code>Build time</code> (e.g. 2024-10-29 12:10:09 +00:00), <code>Rust version</code> (e.g. 1.80.1 3f5fd8dd4 2024-08-06), <code>Toolchain channel</code> (e.g. stable-x86_64-unknown-linux-gnu) Usage Application RustJavaTypescriptSwift <p>get_build_info</p> <p>getBuildInfo</p> <p>getBuildInfo</p> <p>Not available yet!</p> <pre><code>public func getBuildInfo() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#user-functions","title":"User functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#creating-a-new-user","title":"Creating a new user","text":"Method Arguments Returns Dependencies Level Repeat Create a new user <code>username</code> - The username of the new user. Constructor, Set Configuration Basic User RustJavaTypescriptSwift <p>create_new_user</p> <p>createNewUser</p> <p>createNewUser</p> <p>Not available yet!</p> <pre><code>public func createNewUser(username: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#initializing-a-user","title":"Initializing a user","text":"Method Arguments Returns Dependencies Level Repeat Initialize a user <code>username</code> - The username of the user to initialize. Constructor, Set Configuration, Refresh access token, Create new user Usage Application RustJavaTypescriptSwift <p>init_user</p> <p>initializeUser</p> <p>initializeUser</p> <p>Not available yet!</p> <pre><code>public func initUser(username: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#refreshing-access-token","title":"Refreshing access token","text":"Method Arguments Returns Dependencies Level Repeat Refresh access token <code>access_token</code> - The new access token to be set. Constructor, Set Configuration Basic Application RustJavaTypescriptSwift <p>refresh_access_token</p> <p>refreshAccessToken</p> <p>refreshAccessToken</p> <p>Not available yet!</p> <pre><code>public func refreshAccessToken(access_token: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#checking-kyc-status","title":"Checking KYC status","text":"Method Arguments Returns Dependencies Level Repeat Check if the user's KYC status is verified <code>username</code> - The username of the user to check KYC status for. Returns <code>true</code> if the KYC status is verified, or <code>false</code> if it is not verified. User initialization Usage Application RustJavaTypescriptSwift <p>is_kyc_status_verified</p> <p>isKycVerified</p> <p>isKycVerified</p> <p>Not available yet!</p> <pre><code>public func isKycVerified(username: String) throws\n-&gt; Bool\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#delete-user","title":"Delete user","text":"Method Arguments Returns Dependencies Level Repeat Delete the currently active user and their wallet <code>pin</code> - The PIN of the user to be deleted. Required only if the user has created a wallet. User initialization Usage Application RustJavaTypescriptSwift <p>delete_user</p> <p>deleteUser</p> <p>deleteUser</p> <p>Not available yet!</p> <pre><code>public func deleteUser(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#wallet-functions","title":"Wallet functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet","title":"Create new wallet","text":"Method Arguments Returns Dependencies Level Repeat Creates a new wallet for the user with the specified PIN and password <code>pin</code> - The PIN for the wallet Returns the mnemonic phrase of the newly created wallet if successful. User initialization Usage User RustJavaTypescriptSwift <p>create_wallet_from_new_mnemonic</p> <p>createNewWallet</p> <p>createNewWallet</p> <p>Not available yet!</p> <pre><code>public func createNewWallet(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet-from-mnemonic","title":"Create new wallet from mnemonic","text":"Method Arguments Returns Dependencies Level Repeat Create a wallet from existing mnemonic <code>pin</code> - The PIN for the wallet, <code>mnemonic</code> - The mnemonic to migrate from User initialization Usage User RustJavaTypescriptSwift <p>create_wallet_from_existing_mnemonic</p> <p>createWalletFromMnemonic</p> <p>createWalletFromMnemonic</p> <p>Not available yet!</p> <pre><code>public func createWalletFromMnemonic(pin: String, mnemonic: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet-from-backup","title":"Create new wallet from backup","text":"Method Arguments Returns Dependencies Level Repeat Create a wallet from existing backup <code>pin</code> - The PIN for the wallet, <code>backup</code> - The bytes representing the backup file contents, <code>backup_password</code> - The password used when creating the backup User initialization Usage Application RustJavaTypescriptSwift <p>create_wallet_from_backup</p> <p>createWalletFromBackup</p> <p>createWalletFromBackup</p> <p>Not available yet!</p> <pre><code>public func restoreWalletFromBackup(pin: String, backup: RustVec&lt;UInt8&gt;, backup_password: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-a-wallet-backup","title":"Create a wallet backup","text":"Method Arguments Returns Dependencies Level Repeat Create a wallet backup <code>backup_password</code> - The password for the backup Returns the bytes of the created backup file if successful. User initialization Usage Application RustJavaTypescriptSwift <p>create_wallet_backup</p> <p>createWalletBackup</p> <p>createWalletBackup</p> <p>Not available yet!</p> <pre><code>public func createWalletBackup(backup_password: String) throws -&gt; RustVec&lt;UInt8&gt;\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#verify-mnemonic","title":"Verify mnemonic","text":"Method Arguments Returns Dependencies Level Repeat Verifies the mnemonic by checking if it matches the stored mnemonic <code>pin</code> - The PIN for the wallet, <code>mnemonic</code> - The mnemonic to verify Returns <code>true</code> or <code>false</code> whether the mnemonic is successfully verified. User initialization Usage User RustJavaTypescriptSwift <p>verify_mnemonic</p> <p>verifyMnemonic</p> <p>verifyMnemonic</p> <p>Not available yet!</p> <pre><code>public func verifyMnemonic(pin: String, mnemonic: String) throws -&gt; Bool\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#delete-wallet","title":"Delete wallet","text":"<p>Warning</p> <p>Deletes the currently active wallet, potentially resulting in loss of funds if the mnemonic or wallet is not backed up.</p> Method Arguments Returns Dependencies Level Repeat Delete the currently active wallet <code>pin</code> - The PIN for the wallet Wallet initialization Usage Application RustJavaTypescriptSwift <p>delete_wallet</p> <p>deleteWallet</p> <p>deleteWallet</p> <p>Not available yet!</p> <pre><code>public func deleteWallet(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#verify-pin","title":"Verify pin","text":"Method Arguments Returns Dependencies Level Repeat Verifies the pin for the wallet <code>pin</code> - The pin to verify Wallet initialization Usage Application RustJavaTypescriptSwift <p>verify_pin</p> <p>pinVerify</p> <p>verifyPin</p> <p>Not available yet!</p> <pre><code>public func verifyPin(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#reset-pin","title":"Reset pin","text":"Method Arguments Returns Dependencies Level Repeat Resets the pin for the wallet with a new pin by using the existing pin <code>pin</code> - The current pin for the wallet, <code>new_pin</code> - The new pin to set for the wallet Wallet initialization Usage Application RustJavaTypescriptSwift <p>change_pin</p> <p>pinReset</p> <p>resetPin</p> <p>Not available yet!</p> <pre><code>public func resetPin(pin: String, new_pin: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-wallet-password","title":"Set wallet password","text":"Method Arguments Returns Dependencies Level Repeat Set the password for the wallet using the provided pin and new password. If the password is already set, this changes it to the new password. Use <code>is_wallet_password_set</code> to check if the password is already set. <code>pin</code> - The new or existing PIN for the wallet, <code>new_password</code> - The new password to set for the wallet Wallet initialization Usage Application RustJavaTypescriptSwift <p>set_wallet_password</p> <p>setWalletPassword</p> <p>setWalletPassword</p> <p>Not available yet!</p> <pre><code>public func setWalletPassword(pin: String, new_password: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#is-wallet-password-set","title":"Is wallet password set","text":"Method Arguments Returns Dependencies Level Repeat Check if the password is already set. Useful to prompt the user to setup one if it has not yet been done. See also <code>set_wallet_password</code> for how to set a new password and change an existing password. Returns <code>true</code> or <code>false</code> whether or not the password is already set. Wallet initialization Usage Application RustJavaTypescriptSwift <p>is_wallet_password_set</p> <p>isWalletPasswordSet</p> <p>isWalletPasswordSet</p> <p>Not available yet!</p> <pre><code>public func isWalletPasswordSet() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#generate-a-new-address","title":"Generate a new address","text":"Method Arguments Returns Dependencies Level Repeat Generates a new receiver address for the wallet based on the selected network. <code>pin</code> - The PIN for the wallet Returns the generated address as a <code>String</code> if successful. Wallet initialization, Set network Usage Application RustJavaTypescriptSwift <p>generate_new_address</p> <p>generateNewAddress</p> <p>generateNewAddress</p> <p>Not available yet!</p> <pre><code>public func generateNewAddress(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-balance","title":"Get balance","text":"Method Arguments Returns Dependencies Level Repeat Fetches the balance of the user from the wallet <code>pin</code> - The PIN for the wallet Returns the balance as a <code>f64</code> if successful. Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_balance</p> <p>getWalletBalance</p> <p>getWalletBalance</p> <p>Not available yet!</p> <pre><code>public func getBalance(pin: String) throws -&gt; Float\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-wallet-transactions","title":"Get wallet transactions","text":"Method Arguments Returns Dependencies Level Repeat Wallet transaction list <code>pin</code> - The PIN for the wallet, <code>start</code> - The starting page number for paginatation, <code>limit</code> - The page limit size for each page Returns the list of transactions made on the wallet as an array of <code>WalletTxInfo</code> object or a serialized JSON of the same, if successful. Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_wallet_tx_list</p> <p>getWalletTransactionList</p> <p>getWalletTransactionList</p> <p>Not available yet!</p> <pre><code>public func getWalletTransactionList(pin: String, start: UInt64, limit: UInt64) throws -&gt; Rustvec&lt;WalletTxInfo&gt;\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#wallettxinfo","title":"WalletTxInfo","text":"RustJSON <pre><code>pub struct WalletTxInfo {\n/// Transaction creation date\npub date: String,\n/// Contains block id\npub block_id: Option&lt;String&gt;,\n/// Transaction id for particular transaction\npub transaction_id: String,\n/// Describes type of transaction\npub incoming: bool,\n/// Amount of transfer\npub amount: f64,\n/// Name of the network [convert network_id to string based on the value]\npub network: String,\n/// Status of the transfer\npub status: String,\n/// Url of network\npub explorer_url: Option&lt;String&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"&lt;http://json-schema.org/draft-07/schema#&gt;\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"date\": {\n            \"type\": \"string\",\n            \"description\": \"Transaction creation date\"\n        },\n        \"block_id\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Contains block id\"\n        },\n        \"transaction_id\": {\n            \"type\": \"string\",\n            \"description\": \"Transaction id for particular transaction\"\n        },\n        \"incoming\": {\n            \"type\": \"boolean\",\n            \"description\": \"Describes type of transaction\"\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"Amount of transfer\"\n        },\n        \"network\": {\n            \"type\": \"string\",\n            \"description\": \"Name of the network [convert network_id to string based on the value]\"\n        },\n        \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status of the transfer\"\n        },\n        \"explorer_url\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Url of network\"\n        }\n    },\n    \"required\": [\"date\", \"transaction_id\", \"incoming\", \"amount\", \"network\", \"status\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-wallet-transaction","title":"Get wallet transaction","text":"Method Arguments Returns Dependencies Level Repeat Single wallet transaction <code>pin</code> - The PIN for the wallet, <code>tx_id</code> - The transaction id on the network Returns the transactions made on the wallet with the given id as <code>WalletTxInfo</code> object or a serialized JSON of the same, if successful. Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_wallet_tx</p> <p>getWalletTransaction</p> <p>getWalletTransaction</p> <p>Not available yet!</p> <pre><code>public func getWalletTransaction(pin: String, transactionId: String) throws -&gt; WalletTxInfo\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-recovery-share","title":"Set recovery share","text":"Method Arguments Returns Dependencies Level Repeat Sets the recovery share for the users wallet. <code>share</code> - The recovery share to upload. User initialization Usage Application RustJavaTypescriptSwift <p>set_recovery_share</p> <p>setRecoveryShare</p> <p>setRecoveryShare</p> <p>Not available yet!</p> <pre><code>public func setRecoveryShare(share: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-recovery-share","title":"Get recovery share","text":"Method Arguments Returns Dependencies Level Repeat Get the recovery share for the users wallet. User initialization Usage Application RustJavaTypescriptSwift <p>get_recovery_share</p> <p>getRecoveryShare</p> <p>getRecoveryShare</p> <p>Not available yet!</p> <pre><code>public func getRecoveryShare() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswap-functions","title":"Viviswap functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#start-kyc-verification-for-viviswap","title":"Start KYC Verification for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Create a new viviswap user and initialize KYC verification <code>mail</code> - The email address of the user, <code>terms_accepted</code> - A boolean indicating whether the terms have been accepted Returns <code>NewViviswapUser</code> object if successful. User initialization Usage Application RustJavaTypescriptSwift <p>start_kyc_verification_for_viviswap</p> <p>startViviswapKyc</p> <p>startKycVerificationForViviswap</p> <p>Not available yet!</p> <pre><code>public func startKycVerificationForViviswap(mail: String, termsAccepted: Bool) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#newviviswapuser","title":"NewViviswapUser","text":"RustJSON <pre><code>pub struct NewViviswapUser {\n/// Username of new viviswap user\npub username: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"&lt;http://json-schema.org/draft-07/schema#&gt;\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Username of new viviswap user\"\n        }\n    },\n    \"required\": [\"username\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-kyc-details-for-viviswap","title":"Get KYC details for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Get current kyc status of viviswap Returns <code>ViviswapKycStatus</code> object if successful. User initialization Usage Application RustJavaTypescriptSwift <p>get_kyc_details_for_viviswap</p> <p>getViviswapKyc</p> <p>getKycDetailsForViviswap</p> <p>Not available yet!</p> <pre><code>public func getKycDetailsForViviswap() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapkycstatus","title":"ViviswapKycStatus","text":"RustJSON <pre><code>pub struct ViviswapKycStatus {\n    /// full name of the user\n    pub full_name: String,\n    /// the current submission step in the KYC onboarding process for the user\n    pub submission_step: ViviswapVerificationStep,\n    /// the current verified step in the KYC onboarding process for the user\n    pub verified_step: ViviswapVerificationStep,\n    /// the user verification status\n    pub verification_status: ViviswapVerificationStatus,\n    /// The monthly swap limit in euros\n    pub monthly_limit_eur: f32,\n}\npub enum ViviswapVerificationStep {\n    /// no verification step (no next verification step available)\n    Undefined,\n    /// general verification step\n    General,\n    /// personal verification step\n    Personal,\n    /// residence verification step\n    Residence,\n    /// identity verification step\n    Identity,\n    /// amla general verification step\n    Amla,\n    /// document verification step\n    Documents,\n}\npub enum ViviswapVerificationStatus {\n    /// The user is fully verified\n    Verified,\n    /// The user is not verified\n    Unverified,\n    /// The user is partially verified\n    PartiallyVerified,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"full_name\": {\n            \"type\": \"string\",\n            \"description\": \"Full name of the user\"\n        },\n        \"submission_step\": {\n            \"type\": \"string\",\n            \"enum\": [\"Undefined\", \"General\", \"Personal\", \"Residence\", \"Identity\", \"Amla\", \"Documents\"],\n            \"description\": \"The current submission step in the KYC onboarding process for the user\"\n        },\n        \"verified_step\": {\n            \"type\": \"string\",\n            \"enum\": [\"Undefined\", \"General\", \"Personal\", \"Residence\", \"Identity\", \"Amla\", \"Documents\"],\n            \"description\": \"The current verified step in the KYC onboarding process for the user\"\n        },\n        \"verification_status\": {\n            \"type\": \"string\",\n            \"enum\": [\"Verified\", \"Unverified\", \"PartiallyVerified\"],\n            \"description\": \"The user verification status\"\n        },\n        \"monthly_limit_eur\": {\n            \"type\": \"number\",\n            \"description\": \"The monthly swap limit in euros\"\n        }\n    },\n    \"required\": [\"full_name\", \"submission_step\", \"verified_step\", \"verification_status\", \"monthly_limit_eur\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-partial-kyc-for-viviswap","title":"Update partial KYC for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Update the kyc details for viviswap to be submitted <code>is_individual</code> - Whether the user is an individual, <code>is_pep</code> - Whether the user is a politically exposed person, <code>is_us_citizen</code> - Whether the user is a US citizen, <code>is_regulatory_disclosure</code> - Whether the user has accepted the regulatory disclosure, <code>country_of_residence</code> - The country of residence of the user, <code>nationality</code> - The nationality of the user, <code>full_name</code> - The full name of the user, <code>date_of_birth</code> - The date of birth of the user Returns <code>ViviswapPartiallyKycDetails</code> object containing the partially updated KYC details. User initialization Usage Application RustJavaTypescriptSwift <p>update_kyc_partially_status_for_viviswap</p> <p>updateViviswapKycPartial</p> <p>updateKycPartiallyStatusForViviswap</p> <p>Not available yet!</p> <pre><code>public func updateKycPartiallyStatusForViviswap(\n    isIndividual: Bool,\n    isPep: Bool,\n    isUsCitizen: Bool,\n    isRegulatoryDisclosure: Bool,\n    countryOfResidence: String,\n    nationality: String,\n    fullName: String,\n    dateOfBirth: String\n) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswappartiallykycdetails","title":"ViviswapPartiallyKycDetails","text":"RustJSON <pre><code>pub struct ViviswapPartiallyKycDetails {\n    /// Is the user an individual\n    pub is_individual: Option&lt;bool&gt;,\n    /// Is the user a politically exposed person\n    pub is_pep: Option&lt;bool&gt;,\n    /// Is the user a US citizen\n    pub is_us_citizen: Option&lt;bool&gt;,\n    /// Is the regulatory disclosure confirmed by user\n    pub is_regulatory_disclosure: Option&lt;bool&gt;,\n    /// The country of tax residence of the user\n    pub country_of_residence: Option&lt;String&gt;,\n    /// The user's nationality\n    pub nationality: Option&lt;String&gt;,\n    /// The full name of the user as per his legal documents\n    pub full_name: Option&lt;String&gt;,\n    /// The date of birth of the user as per his legal documents\n    pub date_of_birth: Option&lt;String&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"is_individual\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user an individual\"\n        },\n        \"is_pep\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user a politically exposed person\"\n        },\n        \"is_us_citizen\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user a US citizen\"\n        },\n        \"is_regulatory_disclosure\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the regulatory disclosure confirmed by user\"\n        },\n        \"country_of_residence\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The country of tax residence of the user\"\n        },\n        \"nationality\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The user's nationality\"\n        },\n        \"full_name\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The full name of the user as per his legal documents\"\n        },\n        \"date_of_birth\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The date of birth of the user as per his legal documents\"\n        }\n    }\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#submit-partial-kyc-for-viviswap","title":"Submit partial KYC for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Submit the kyc details for viviswap User initialization Usage Application RustJavaTypescriptSwift <p>submit_kyc_partially_status_for_viviswap</p> <p>submitViviswapKycPartial</p> <p>submitKycPartiallyStatusForViviswap</p> <p>Not available yet!</p> <pre><code>public func submitKycPartiallyStatusForViviswap() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-iban-for-viviswap","title":"Get IBAN for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Get current iban of viviswap user Returns <code>ViviswapAddressDetail</code> object if successful. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>get_iban_for_viviswap</p> <p>getIbanViviswap</p> <p>getIbanViviswap</p> <p>Not available yet!</p> <pre><code>public func getIbanViviswap() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapaddressdetail","title":"ViviswapAddressDetail","text":"RustJSON <pre><code>pub struct ViviswapAddressDetail {\n    /// the unique id of the address detail\n    pub id: String,\n    /// the address used in the detail\n    pub address: String,\n    /// the status from viviswap, whether the address is verified\n    pub is_verified: bool,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique id of the address detail\"\n        },\n        \"address\": {\n            \"type\": \"string\",\n            \"description\": \"The address used in the detail\"\n        },\n        \"is_verified\": {\n            \"type\": \"boolean\",\n            \"description\": \"The status from viviswap, whether the address is verified\"\n        }\n    },\n    \"required\": [\"id\", \"address\", \"is_verified\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-iban-for-viviswap","title":"Update IBAN for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Update IBAN of viviswap user <code>pin</code> - The user's PIN, <code>address</code> - The new IBAN address Returns <code>ViviswapAddressDetail</code> object if successful. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>update_iban_for_viviswap</p> <p>updateIbanViviswap</p> <p>updateIbanViviswap</p> <p>Not available yet!</p> <pre><code>public func updateIbanViviswap(pin: String, address: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-deposit-with-viviswap","title":"Create deposit with viviswap","text":"Method Arguments Returns Dependencies Level Repeat Create deposit for viviswap user <code>pin</code> - The PIN for the wallet Returns <code>ViviswapDeposit</code> object if successful. Wallet initialization, Get KYC Details for viviswap, Update IBAN Usage Application RustJavaTypescriptSwift <p>create_deposit_with_viviswap</p> <p>depositWithViviswap</p> <p>createDepositWithViviswap</p> <p>Not available yet!</p> <pre><code>public func depositWithViviswap(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapdeposit","title":"ViviswapDeposit","text":"RustJSON <pre><code>pub struct ViviswapDeposit {\n    /// The unique UUID of the contract\n    pub contract_id: String,\n    /// The deposit address (crypto) where the swap will put the funds from fiat\n    pub deposit_address: String,\n    /// The details of the deposit (for the user)\n    pub details: ViviswapDepositDetails,\n}\npub struct ViviswapDepositDetails {\n    /// The reference to be entered by the user in his SEPA bank transfer\n    pub reference: String,\n    /// The name of the beneficiary receiving the SEPA transfer\n    pub beneficiary: String,\n    /// The name of the bank of the beneficiary\n    pub name_of_bank: String,\n    /// The address of the bank of the beneficiary\n    pub address_of_bank: String,\n    /// The IBAN of the beneficiary\n    pub iban: String,\n    /// The BIC/SWIFT code for the SEPA transfer\n    pub bic: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique UUID of the contract\"\n        },\n        \"deposit_address\": {\n            \"type\": \"string\",\n            \"description\": \"The deposit address (crypto) where the swap will put the funds from fiat\"\n        },\n        \"details\": {\n            \"type\": \"object\",\n            \"description\": \"The details of the deposit (for the user)\",\n            \"properties\": {\n                \"reference\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reference to be entered by the user in his SEPA bank transfer\"\n                },\n                \"beneficiary\": {\n                    \"type\": \"string\",\n                    \"description\": \"The name of the beneficiary receiving the SEPA transfer\"\n                },\n                \"name_of_bank\": {\n                    \"type\": \"string\",\n                    \"description\": \"The name of the bank of the beneficiary\"\n                },\n                \"address_of_bank\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the bank of the beneficiary\"\n                },\n                \"iban\": {\n                    \"type\": \"string\",\n                    \"description\": \"The IBAN of the beneficiary\"\n                },\n                \"bic\": {\n                    \"type\": \"string\",\n                    \"description\": \"The BIC/SWIFT code for the SEPA transfer\"\n                }\n            },\n            \"required\": [\"reference\", \"beneficiary\", \"name_of_bank\", \"address_of_bank\", \"iban\", \"bic\"]\n        }\n    },\n    \"required\": [\"contract_id\", \"deposit_address\", \"details\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-viviswap-address-detail","title":"Create viviswap address detail","text":"Method Arguments Returns Dependencies Level Repeat Create address detail for viviswap user <code>pin</code> - The PIN for the wallet Returns <code>ViviswapAddressDetail</code> object if successful. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>create_detail_for_viviswap</p> <p>createViviswapDetail</p> <p>createDetailForViviswap</p> <p>Not available yet!</p> <pre><code>public func createViviswapDetail(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-withdrawal-with-viviswap","title":"Create withdrawal with viviswap","text":"Method Arguments Returns Dependencies Level Repeat Create address detail for viviswap user <code>amount</code> - The amount of the withdrawal, <code>pin</code> - The optional PIN for verification, <code>data</code> - Optional data which can be assigned to the transaction Returns <code>ViviswapWithdrawal</code> object if successful. Wallet initialization, Get KYC Details for viviswap, Update IBAN Usage Application RustJavaTypescriptSwift <p>create_withdrawal_with_viviswap</p> <p>withdrawWithViviswap</p> <p>createWithdrawalWithViviswap</p> <p>Not available yet!</p> <pre><code>public func withdrawWithViviswap(amount: Float, pin: String, data: [UInt8]) throws -&gt; ViviswapWithdrawal\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapwithdrawal","title":"ViviswapWithdrawal","text":"RustJSON <pre><code>pub struct ViviswapWithdrawal {\n    /// The unique UUID to track the withdrawal contract\n    pub contract_id: String,\n    /// The deposit address, in this case the IBAN of the user, where fiat will be deposited.\n    pub deposit_address: String,\n    /// The details of the withdrawal\n    pub details: ViviswapWithdrawalDetails,\n}\npub struct ViviswapWithdrawalDetails {\n    /// The reference used by viviswap for the SEPA transfer\n    pub reference: String,\n    /// The id of the unique wallet internal to viviswap\n    pub wallet_id: String,\n    /// The crypto address of viviswap where the crypto swap is to be sent\n    pub crypto_address: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique UUID of the contract\"\n        },\n        \"withdrawal_address\": {\n            \"type\": \"string\",\n            \"description\": \"The withdrawal address (crypto) where the swap will put the funds from fiat\"\n        },\n        \"details\": {\n            \"type\": \"object\",\n            \"description\": \"The details of the withdrawal (for the user)\",\n            \"properties\": {\n                \"reference\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reference used by viviswap for the SEPA transfer\"\n                },\n                \"wallet_id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The id of the unique wallet internal to viviswap\"\n                },\n                \"crypto_address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The crypto address of viviswap where the crypto swap is to be sent\"\n                }\n            },\n            \"required\": [\"reference\", \"wallet_id\", \"crypto_address\"]\n        }\n    },\n    \"required\": [\"contract_id\", \"withdrawal_address\", \"details\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-swap-details","title":"Get swap details","text":"Method Arguments Returns Dependencies Level Repeat Get swap details <code>order_id</code> - The ID of the swap order. Returns <code>Order</code> object containing the swap order details. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>get_swap_details</p> <p>getSwapDetails</p> <p>getSwapDetails</p> <p>Not available yet!</p> <pre><code>public func getSwapDetails(order_id: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#order","title":"Order","text":"RustJSON <pre><code>pub struct Order {\n    pub id: String,\n    pub is_payed_out: bool,\n    pub is_approved: bool,\n    pub is_canceled: bool,\n    pub fees_amount_eur: f32,\n    pub crypto_fees: f32,\n    pub contract_id: String,\n    pub incoming_payment_method_id: String,\n    pub incoming_payment_method_currency: String,\n    pub incoming_amount: f32,\n    pub incoming_course: f32,\n    pub outgoing_payment_method_id: String,\n    pub outgoing_payment_method_currency: String,\n    pub outgoing_amount: f32,\n    pub outgoing_course: f32,\n    pub refund_amount: Option&lt;f32&gt;,\n    pub refund_course: Option&lt;f32&gt;,\n    pub refund_payment_method_id: Option&lt;String&gt;,\n    pub status: i32,\n    pub creation_date: String,\n    pub incoming_payment_detail: Option&lt;PaymentDetail&gt;,\n    pub outgoing_payment_detail: Option&lt;PaymentDetail&gt;,\n    pub refund_payment_detail: Option&lt;PaymentDetail&gt;,\n}\n\npub struct PaymentDetail {\n    pub id: String,\n    pub address: String,\n    pub is_verified: Option&lt;bool&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique id of the order\"\n        },\n        \"is_payed_out\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is payed out\"\n        },\n        \"is_approved\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is approved\"\n        },\n        \"is_canceled\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is canceled\"\n        },\n        \"fees_amount_eur\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of fees in EUR\"\n        },\n        \"crypto_fees\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of crypto fees\"\n        },\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the contract\"\n        },\n        \"incoming_payment_method_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the incoming payment method\"\n        },\n        \"incoming_payment_method_currency\": {\n            \"type\": \"string\",\n            \"description\": \"The currency of the incoming payment method\"\n        },\n        \"incoming_amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of the incoming payment\"\n        },\n        \"incoming_course\": {\n            \"type\": \"number\",\n            \"description\": \"The course of the incoming payment\"\n        },\n        \"outgoing_payment_method_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the outgoing payment method\"\n        },\n        \"outgoing_payment_method_currency\": {\n            \"type\": \"string\",\n            \"description\": \"The currency of the outgoing payment method\"\n        },\n        \"outgoing_amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of the outgoing payment\"\n        },\n        \"outgoing_course\": {\n            \"type\": \"number\",\n            \"description\": \"The course of the outgoing payment\"\n        },\n        \"refund_amount\": {\n            \"type\": [\"number\", \"null\"],\n            \"description\": \"The amount of the refund\"\n        },\n        \"refund_course\": {\n            \"type\": [\"number\", \"null\"],\n            \"description\": \"The course of the refund\"\n        },\n        \"refund_payment_method_id\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The id of the refund payment method\"\n        },\n        \"status\": {\n            \"type\": \"integer\",\n            \"description\": \"The status of the order\"\n        },\n        \"creation_date\": {\n            \"type\": \"string\",\n            \"description\": \"The creation date of the order\"\n        },\n        \"incoming_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the incoming payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        },\n        \"outgoing_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the outgoing payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        },\n        \"refund_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the refund payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        }\n    },\n    \"required\": [\"id\", \"is_payed_out\", \"is_approved\", \"is_canceled\", \"fees_amount_eur\", \"crypto_fees\", \"contract_id\", \"incoming_payment_method_id\", \"incoming_payment_method_currency\", \"incoming_amount\", \"incoming_course\", \"outgoing_payment_method_id\", \"outgoing_payment_method_currency\", \"outgoing_amount\", \"outgoing_course\", \"status\", \"creation_date\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-swap-lists","title":"Get swap lists","text":"Method Arguments Returns Dependencies Level Repeat Get swap list <code>start</code> - The start page parameter, <code>limit</code> - The pagination limit parameter Returns an array of <code>Order</code> object containing the swap order details for each swap. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>get_swap_list</p> <p>getSwapList</p> <p>getSwapList</p> <p>Not available yet!</p> <pre><code>public func getSwapList(page: UInt64, limit: UInt64) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-exchange-rate","title":"Get exchange rate","text":"Method Arguments Returns Dependencies Level Repeat Get the exchange rate for the selected currency Returns the latest exchange rate Usage Application RustJavaTypescriptSwift <p>get_exchange_rate</p> <p>getExchangeRate</p> <p>getExchangeRate</p> <p>Not available yet!</p> <pre><code>public func getExchangeRate() throws -&gt; Float\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#transaction-functions","title":"Transaction functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-purchase-request","title":"Create purchase request","text":"Method Arguments Returns Dependencies Level Repeat Create purchase request <code>receiver</code> - The receiver's username, <code>amount</code> - The amount of the purchase, <code>product_hash</code> - The hash of the product, <code>app_data</code> - The application data, <code>purchase_type</code> - The type of the purchase Returns the purchase ID. This is an internal index used to reference the transaction in etopay Wallet initialization Usage Application RustJavaTypescriptSwift <p>create_purchase_request</p> <p>purchaseRequestCreate</p> <p>createPurchaseRequest</p> <p>Not available yet!</p> <pre><code>public func createPurchaseRequest(\n    receiver: String, amount: Double, product_hash: String, app_data: String, purchase_type: String\n) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-purchase-details","title":"Get purchase details","text":"Method Arguments Returns Dependencies Level Repeat Get purchase details <code>purchase_id</code> - The ID of the purchase. Returns the purchase details as <code>PurchaseDetails</code> object Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_purchase_details</p> <p>purchaseDetails</p> <p>getPurchaseDetails</p> <p>Not available yet!</p> <pre><code>public func getPurchaseDetails(purchase_id: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#purchasedetails","title":"PurchaseDetails","text":"RustJSON <pre><code>    pub struct PurchaseDetails {\n        /// The sender address where the fees goes to.\n        pub system_address: String,\n        /// The amount to be paid.\n        pub amount: Decimal,\n        /// The status of transaction\n        pub status: ApiTxStatus,\n    }\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"system_address\": {\n            \"type\": \"string\",\n            \"description\": \"The sender address where the fees goes to.\"\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount to be paid\"\n        },\n        \"status\": {\n            \"type\": \"object\",\n            \"description\": \"Status of the transfer\",\n            \"enum\": [\"Pending\", \"WaitingForVerification\", \"Valid\", \"Invalid\", \"ProcessingIncoming\", \"ProcessingOutgoing\", \"Completed\", \"Failed\"]\n        },\n    },\n    \"required\": [\"system_address\", \"amount\", \"status\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#confirm-purchase-request","title":"Confirm purchase request","text":"Method Arguments Returns Dependencies Level Repeat Confirm purchase request <code>pin</code> - The PIN of the user, <code>purchase_id</code> - The ID of the purchase. Wallet initialization Usage Application RustJavaTypescriptSwift <p>confirm_purchase_request</p> <p>purchaseRequestConfirm</p> <p>confirmPurchaseRequest</p> <p>Not available yet!</p> <pre><code>public func confirmPurchaseRequest(pin: String, purchase_id: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#send-amount","title":"Send amount","text":"Method Arguments Returns Dependencies Level Repeat Send amount to the receiver address. <code>pin</code> - The PIN of the user, <code>address</code> - The receiver's address, <code>amount</code> - The amount to send, <code>data</code> - Optional data which can be assigned to the transaction Wallet initialization Usage Application RustJavaTypescriptSwift <p>send_amount</p> <p>sendAmount</p> <p>sendAmount</p> <p>Not available yet!</p> <pre><code>public func sendAmount(pin: String, address: String, amount: Double, data: [UInt8]) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-purchase-list","title":"Get Purchase list","text":"Method Arguments Returns Dependencies Level Repeat Get purchase list <code>start</code> - The starting page number, <code>limit</code> - The maximum number of transactions per page Returns a list of purchases as <code>TxInfo</code> object, if successful. User initialization Usage Application RustJavaTypescriptSwift <p>get_tx_list</p> <p>txList</p> <p>getTransactionList</p> <p>Not available yet!</p> <pre><code>public func getTxList(start: UInt64, limit: UInt64) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#txinfo","title":"TxInfo","text":"RustJSON <pre><code>pub struct TxInfo {\n    /// Tx creation date, if available\n    pub date: Option&lt;String&gt;,\n    /// receiver of the transaction\n    pub receiver: String,\n    /// etopay reference id for the transaction\n    pub reference_id: String,\n    /// Application specific metadata attached to the tx\n    pub application_metadata: Option&lt;ApplicationMetadata&gt;,\n    /// Amount of transfer\n    pub amount: f64,\n    /// Currency of transfer\n    pub currency: String,\n    /// Status of the transfer\n    pub status: TxStatus,\n    /// The transaction hash on the network\n    pub transaction_hash: Option&lt;String&gt;,\n    /// Exchange rate\n    pub course: f64,\n}\n\npub struct ApplicationMetadata {\n    pub product_hash: String,\n    pub reason: String,\n    pub purchase_model: String,\n    pub app_data: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"date\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Tx creation date, if available\"\n        },\n        \"receiver\": {\n            \"type\": \"string\",\n            \"description\": \"receiver of the transaction\"\n        },\n        \"reference_id\": {\n            \"type\": \"string\",\n            \"description\": \"etopay reference id for the transaction\"\n        },\n        \"application_metadata\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"Application specific metadata attached to the tx\",\n            \"properties\": {\n                \"product_hash\": {\n                    \"type\": \"string\",\n                    \"description\": \"The product hash\"\n                },\n                \"reason\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reason for the transaction\"\n                },\n                \"purchase_model\": {\n                    \"type\": \"string\",\n                    \"description\": \"The purchase model\"\n                },\n                \"app_data\": {\n                    \"type\": \"string\",\n                    \"description\": \"The application data\"\n                }\n            },\n            \"required\": [\"product_hash\", \"reason\", \"purchase_model\", \"app_data\"]\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"Amount of transfer\"\n        },\n        \"currency\": {\n            \"type\": \"string\",\n            \"description\": \"Currency of transfer\"\n        },\n        \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status of the transfer\",\n            \"enum\": [\"Pending\", \"Valid\", \"Invalid\", \"ProcessingMain\", \"ProcessingAux\", \"Completed\", \"Failed\"]\n        },\n        \"transaction_hash\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The transaction hash on the network\"\n        },\n        \"course\": {\n            \"type\": \"number\",\n            \"description\": \"Exchange rate\"\n        }\n    },\n    \"required\": [\"receiver\", \"reference_id\", \"amount\", \"currency\", \"status\", \"course\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#postident-functions","title":"Postident functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#start-kyc-verification-for-postident","title":"Start kyc verification for postident","text":"Method Arguments Returns Dependencies Level Repeat Start kyc verification for postident Returns an object <code>NewCaseIdResponse</code> if successful. User initialization Usage Application RustJavaTypescriptSwift <p>start_kyc_verification_for_postident</p> <p>startKycVerificationForPostident</p> <p>startKycVerificationForPostident</p> <p>Not available yet!</p> <pre><code>public func startKycVerificationForPostident() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#newcaseidresponse","title":"NewCaseIdResponse","text":"RustJSON <pre><code>pub struct NewCaseIdResponse {\n    /// New Postident case id\n    pub case_id: String,\n    /// Case url\n    pub case_url: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"case_id\": {\n            \"type\": \"string\",\n            \"description\": \"New Postident case id\"\n        },\n        \"case_url\": {\n            \"type\": \"string\",\n            \"description\": \"Case url\"\n        }\n    },\n    \"required\": [\"case_id\", \"case_url\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-case-details-for-postident","title":"Get case details for postident","text":"Method Arguments Returns Dependencies Level Repeat Get case details for postident Returns an object <code>CaseDetailsResponse</code> if successful. User initialization Usage Application RustJavaTypescriptSwift <p>get_kyc_details_for_postident</p> <p>getKycDetailsForPostident</p> <p>getKycDetailsForPostident</p> <p>Not available yet!</p> <pre><code>public func getKycDetailsForPostident() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#casedetailsresponse","title":"CaseDetailsResponse","text":"RustJSON <pre><code>pub struct CaseDetailsResponse {\n    pub case_id: String,\n    pub archived: bool,\n    pub status: String,\n}\n</code></pre> <pre><code>    {\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n        \"type\": \"object\",\n        \"properties\": {\n            \"case_id\": {\n                \"type\": \"string\",\n                \"description\": \"The Postident case id\"\n            },\n            \"archived\": {\n                \"type\": \"boolean\",\n                \"description\": \"Whether the case is archived\"\n            },\n            \"status\": {\n                \"type\": \"string\",\n                \"description\": \"The status of the case\"\n            }\n        },\n        \"required\": [\"case_id\", \"archived\", \"status\"]\n    }\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-case-status-for-postident","title":"Update case status for postident","text":"Method Arguments Returns Dependencies Level Repeat Update case status for postident <code>case_id</code>: The ID of the case to update. User initialization Usage Application RustJavaTypescriptSwift <p>update_kyc_status_for_postident</p> <p>updateKycStatusForPostident</p> <p>updateKycStatusForPostident</p> <p>Not available yet!</p> <pre><code>public func updateKycStatusForPostident(case_id: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-user-preferred-network","title":"Get user preferred network","text":"Method Arguments Returns Dependencies Level Repeat Fetches the users preferred network Returns the network if successful or an empty value if no preferred network has been set. User initialization Usage Application RustJavaTypescriptSwift <p>get_preferred_network</p> <p>getPreferredNetwork</p> <p>getPreferredNetwork</p> <p>Not available yet!</p> <pre><code>public func getPreferredNetwork() throws -&gt; PreferredNetwork\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-user-preferred-network","title":"Set user preferred network","text":"Method Arguments Returns Dependencies Level Repeat Sets the users preferred network, or resets it if an empty value is provided. <code>network_id</code> - The preferred user network. Optional value. User initialization Usage Application RustJavaTypescriptSwift <p>set_preferred_network</p> <p>setPreferredNetwork</p> <p>setPreferredNetwork</p> <p>Not available yet!</p> <pre><code>public func setPreferredNetwork(network_id: String) throws\n</code></pre>"},{"location":"javadoc/legal/jquery/","title":"Jquery","text":""},{"location":"javadoc/legal/jquery/#jquery-v371","title":"jQuery v3.7.1","text":""},{"location":"javadoc/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.7.1\nCopyright OpenJS Foundation and other contributors, https://openjsf.org/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"javadoc/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"javadoc/legal/jqueryUI/#jquery-ui-v1132","title":"jQuery UI v1.13.2","text":""},{"location":"javadoc/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"},{"location":"rust-docs/doc/static.files/SourceSerif4-LICENSE-3bb119e13b1258b7/","title":"SourceSerif4 LICENSE 3bb119e13b1258b7","text":"<p>Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries. Copyright 2014 - 2023 Adobe (http://www.adobe.com/), with Reserved Font Name \u2018Source\u2019. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.</p> <p>This Font Software is licensed under the SIL Open Font License, Version 1.1.</p> <p>This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL</p>"},{"location":"rust-docs/doc/static.files/SourceSerif4-LICENSE-3bb119e13b1258b7/#sil-open-font-license-version-11-26-february-2007","title":"SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007","text":"<p>PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.</p> <p>The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.</p> <p>DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.</p> <p>\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).</p> <p>\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).</p> <p>\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.</p> <p>\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.</p> <p>PERMISSION &amp; CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:</p> <p>1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.</p> <p>2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.</p> <p>3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.</p> <p>4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.</p> <p>5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.</p> <p>TERMINATION This license becomes null and void if any of the above conditions are not met.</p> <p>DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.</p>"}]}