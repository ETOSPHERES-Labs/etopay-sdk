{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the ETOPay SDK documentation. This comprehensive guide is designed to provide you with all the information you need to install and use the ETOPay SDK effectively.</p> <p>The ETOPay SDK provides the logic for interacting with the ETOPay backend correctly. The SDK plans to help developers with a quicker, safer and easier on-boarding in the web3 world, while using the ETOPay infrastructure to support various use-cases around data monetization.</p> <p>The SDK is divided in various modules which come together to ensure an easy and safe way to incorporate the SDK in the application.</p> <p>For ease of integration, the SDK also generates bindings in various languages for various platforms, especially for mobile platforms, to provide easy integration with native and hybrid mobile app development frameworks.</p> <p>This documentation is primarily intended for developers who are integrating the ETOPay SDK into their applications. It provides a comprehensive guide to installing and using the SDK, with a focus on practical examples and clear, concise explanations.</p> <p>The documentation is divided into following sections. Simply choose one and get started!</p> <ul> <li> <p> Features</p> <p>Know the features before using ETOPay in your applications for a better product-market fit.</p> <p> Features</p> </li> <li> <p> Dashboard</p> <p>Learn how to use the dashboard to manage your projects.</p> <p> Dashboard</p> </li> <li> <p> Installing the SDK</p> <p>This section provides step-by-step instructions on how to install the ETOPay SDK in your development environment.</p> <p> Install</p> </li> <li> <p> Configuring the SDK</p> <p>Here, you'll find information on how to use the SDK's basic features and configure it correctly, complete with code snippets and examples to help you get started.</p> <p> Configure</p> </li> <li> <p> SDK Modules</p> <p>Once you're comfortable with the basics and configuration, this section delves into the core SDK module functions around user and wallet management, kyc onboarding processes, integration with exchanges, helping you leverage the full power of the ETOPay SDK.</p> <p> Modules</p> </li> <li> <p> SDK Examples</p> <p>This section provides a basic overview of the SDK internal structure and explains the different modules and their functions intrinsically.</p> <p> Examples</p> </li> <li> <p> API Reference</p> <p>This section provides a detailed overview of the SDK's API, including descriptions of the different functions, their return values, and the error types you might encounter.</p> <p> Reference</p> </li> </ul> <p>We hope this documentation serves as a valuable resource to explore the capabilities of the ETOPay SDK.</p> <p>Made with  by Team Lobster </p>"},{"location":"Choosing%20ETOPay/Architecture/","title":"Architecture","text":""},{"location":"Choosing%20ETOPay/Architecture/#overview","title":"Overview","text":"<p>The architecture shows the involved participants and explains how the integration of a client application works with .</p>"},{"location":"Choosing%20ETOPay/Architecture/#services","title":"Services","text":"<p>The ETOPay services are a bundle of services, which work together, using various infrastructure components like databases, message queues, caches, etc... to provide the different features as listed here</p> <p>These services are maintained, tested and updated by the development team behind this project. The source code for the same is maintained in a closed source repository with the development team.</p>"},{"location":"Choosing%20ETOPay/Architecture/#web-portal","title":"Web portal","text":"<p>The developers trying to integrate the ETOPay SaaS product would typically access the web portal to register themselves. After the registration, the developer can requisition a fresh new instance for the application from ETOPay through this portal.</p> <p>Additionally, the web portal allows the developers to configure their instance according to their application needs. It can be also used to undertake some application specific settings and modify them as well. For example, setting the identity provider urls and access points, which is owned by the application but may be used by ETOPay to authenticate users or setting a webhook receiver endpoint, where a notification server is already listening to ETOPay internal events, to push notifications to the end-user devices, etc...</p> <p>Currently, on the first request, a staging environment of a fresh ETOPay services instance is deployed. This allows the developers to test their application flow and integration with ETOPay before moving to production. Requesting a production instance is an extra step which needs to be done additionally. This helps the developers to fix a version for their production, while they continue testing new features and releases from ETOPay team on the staging environment, before requesting to update to production.</p> <p>The infrastructure deploys in a private cloud hosted in the european data center. Deployments in client infrastructure and public clouds are currently not possible, however will be considered in the future, for example with client-owned kubernetes cluster or Azure/AWS depolyments. The ETOPay services are coded in software to be fully platform agnostic. Hence, the deployment architecture does not affect the features and working of the services.</p>"},{"location":"Choosing%20ETOPay/Architecture/#integration","title":"Integration","text":"<p>The integration can occur for the client in three different ways:</p> <ol> <li> <p>REST API: A platform-agnostic, robust API to interact with the  features and a modern and sleek documentation.</p> <p>Within this integration, the ETOPay services are exposed via a REST API. The client developers can directly connect to these services using the Open API specification for the services. A drawback for this approach could be that the requirement on the various flows as expected by the ETOPay services needs to be well understood from the documentation. This approach also works only with custodial wallets, which might increase costs for end-users, as compared to a self-custody wallet.</p> </li> <li> <p>SDK: A variety of multi-stack SDKs working together to allow seamless in-app integration with code examples and instructions on best-practices.</p> <p>Here, the client developers can download our SDKs and even modify their behaviour according to their own needs. These SDKs are described in detail and the source code is kept open to allow maximum benefit during integration. Using the SDK gives the advantage to the developers in a way that, the SDK does all the heavy lifting in terms of executing the flows together with the ETOPay service whilst ensuring secure self-custody wallets and user management on end-user devices. This takes away a significant amount of integration effort and allows for a quick time-to-market without needing to understand all particular nuances of ETOPay services.</p> </li> <li> <p>White Label App: A multi-platform white label application with intuitive interfaces for low time to market with fully compliant flows to ensure highest user satisfaction.</p> <p>As the white label application builds on top of the SDK, it provides the client developers with complete UI/UX for maximum integration with minimal effort. The only thing the client developers would need is to adjust the corporate identiy, build the application and ship it to their end-users. The white label app ensures that all the flows are correctly executed, with the most lucid user experience from on-boarding to using the features of ETOPay. Being open source again, the white label application can also be customized for own needs and making an entirely new application would be like simply adding a few new layouts.</p> </li> </ol>"},{"location":"Choosing%20ETOPay/Features/","title":"Features","text":"<p>allows end-users to perform in-app payments to other end-users for services and products offered through the application.</p> <p>solves the problem of P2P payments between end-users, by not becoming a gate-keeper, but a path-finder between consumers for digital data, services and real-world commodities</p> <ul> <li> <p>Complete Wallet Management with MFA (Multi-factor approvals)</p> <p>For end-users with custodial and non-custodial cryptocurrency wallets without the need of additional approval from regulatory authorities</p> </li> <li> <p>KYC onboarding</p> <p>A completed on-boarding with a full-KYC without ever needing to leave the application and jumping in different browsers.</p> </li> <li> <p>Fiat/Cryptocurrency integration</p> <p>Allows loading cryptocurrency wallets from FIAT bank accounts and vice versa all within the application. Hassle-free and no copy pasting strange character addresses in even stranger browser apps.</p> </li> <li> <p>Multi-user app</p> <p>One end-user or multiple end-users on a single device? We have you covered. Every user on the same end-device can work with the highest assurance that their data cannot be seen by anyone else except themselves.</p> </li> <li> <p>Seamless identity integration</p> <p>We integrate directly with our existing identity providers, to avoid the confusion of re-registration and doing the onboarding for the users again.</p> </li> <li> <p>Integrated invoice and receipt</p> <p>The users need not worry for being conform with the tax authorities. We generate the legally exact receipts and invoices for every user automatically.</p> </li> <li> <p>Multi-platform compatible</p> <p>The solution is provided as an SDK (Software Development Kit) for major application platforms like Android, iOS and Web for developer-easy integration.</p> </li> <li> <p>European Data Center</p> <p>All your data stays in EU and never leaves, replicated or sold to anyone. A fully (really!) GDPR compliant solution with no non-EU entities lurking in the shadows of privacy policy.</p> </li> <li> <p>Cyber-secure</p> <p>A periodic vulnerability assessment and penetration testing ensures that the system is robust against attacks and leaks.</p> </li> </ul>"},{"location":"Choosing%20ETOPay/Features/#use-cases","title":"Use-cases","text":"<p>With ETOPay, you can do a lot more than the listed use-cases below. The use-cases just simply show the tip of the iceberg, how you can benefit from integrating ETOPay in your applications:</p> <ol> <li>Data-Marketplace for buying and selling sensor data, digital content or even NFTs.</li> <li>A simple cart checkout with multiple payment and currency options</li> <li>Artist remuneration directly in app for major events</li> <li>A DeFi dApp with a fully embedded wallet, without needing users to download and install shady plugins.</li> <li>Gaming exchanges for in-game artifacts and digital content with exclusive content mangement rights negotiated in real-time between end-users.</li> <li>Scam detection and regulated payments to health-care related products for the elderly</li> </ol>"},{"location":"Choosing%20ETOPay/Licensing/","title":"Licensing","text":""},{"location":"Choosing%20ETOPay/Licensing/#software-licensing-and-open-source","title":"Software licensing and Open Source","text":"<p>The ETOPay SDK is licensed under the AGPL-3.0 license and available on GitHub. If you experience any issues or have a feature request, please open an Issue. We are also happy to accept contributions from the community in the form of Pull Requests.</p>"},{"location":"Choosing%20ETOPay/Philosophy/","title":"Philosophy","text":"<p>The ETOPay project was started with a few basic principles and they are also the guiding values which will continue to motivate the team and all its contributors to work for this project.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#core-principles","title":"Core principles","text":"<p>The following core principles summarize how the team looks at things differently:</p>"},{"location":"Choosing%20ETOPay/Philosophy/#self-realization","title":"Self-realization","text":"<p>Identify the problem: It is always important for us to identify the core problem on the technical front and approach it as an engineer with fixed boundary conditions. It is crucial to understand and realize the crux of a certain system to also get to the core of the underlying problem, rather than waiting for anyone else to explain to us their view of the system and problem.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#awareness","title":"Awareness","text":"<p>Look for solutions: Look around at other people, who might have faced the same problem and look at the solutions they are using. Look at other solutions in totally different systems but with the same problems and see if they are a fit for your problem. Most of the times, the buck stops here and the problem is solved with a possible solution being discovered. But, we do care for one more core principle which influences entirely as to why certain solutions are not the best fits.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#fairness","title":"Fairness","text":"<p>Is it allowed? Not just in terms of legal, but in terms of morality as well. It is very important to consider the sentiments of each and every human and especially their rights, when they interact with our systems. Legally speaking, there might be some grey areas, but morally there are plainly some things which we cannot just allow on principle. And mostly this is how we judge the solutions and the philosophies behind them, as how they would affect us and in turn our customers.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#dexterity","title":"Dexterity","text":"<p>DIY: If there is no solution which is legally and morally correct, or no solution technically at all, then it becomes the time for us to get our hands dirty and dive in completely to solve the problem from its roots and come up with a solution that provides us a way out of the problem once and for all. Resources become no concern as the best available methods, processes and people get attracted to us when we approach a well-aware core problem with fairness also in focus.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#community","title":"Community","text":"<p>One-for-all and all-for one: We strongly believe that we should be rewarded for what we do. And this is also sometimes a driver and motivation behind searching for solutions. In addition, we also equally strongly believe that we do not want to become gate-keepers but path-finders and light-bringers for others like us, searching for solutions in the dark. Putting back our efforts to the community, in a way which allows a beautiful, sustainable ecosystem to flourish makes complete sense, when we start contemplating that, the solutions would themselves never exist, if not for the base provided by the same thriving community.</p> <p>With these core principles guiding us, we just rinse and repeat at every opportunity that comes in-front of us either as a special request, challenge or self-discovered problems. We are affirmed more than once that this belief in the core principles has potential to rescue the world trapped under various gate-keepers to a truly decentralized and fair ecosystem.</p> <p>Hence, it does not come to us as a surprise that, all which we are building fits perfectly in the Web3 context, which also strives to unite over marginalizing or dividing people.</p>"},{"location":"Choosing%20ETOPay/Philosophy/#the-etopay-story","title":"The ETOPay story","text":"<p>began exactly with the simplest of problems: How is it possible for a person to pay another person for goods and services offered on a platform in a way where the platform is not a gate-keeper?</p> <p>With this started our search for solutions and we concluded that there is no platform as such which respects their end-users and their rights like data protection, but rather tries to exploit as much as they can from their users.</p> <p>We started developing ETOPay and we realized that we actually are just using various solutions, which are already available in the community, but just presenting and connecting them in a way that makes it fair, legal and transparent.</p> <p>Taking guidance from our core principles, we have decided to go open source with our solution and give it to the community, not just to help develop it further with us but also use it everywhere, where they encountered gate-keepers. To employ it in a way which guarantees fairness and transparency to their end users, baked right in the solution.</p>"},{"location":"Dashboard/Dashboard/","title":"Dashboard","text":"<p>The backend to the ETOPay SDK is accessible through our dashboard where you can:</p> <ol> <li>Login using GitHub.</li> <li>Manage your active projects.</li> <li>Retrieve the configuration needed to use the ETOPay SDK.</li> <li>Configure secrets required for integrating with KYC providers.</li> </ol>"},{"location":"Dashboard/Dashboard/#login-using-github","title":"Login using GitHub","text":"<p>Open the dashboard and press the button to login through your GitHub account. By logging in and using our platform you agree to the Terms of Service and Privacy Policy. When authorizing the GitHub application, you also agree to that we can access the following information about your account:</p> <ul> <li>Your primary email address (even if it is marked as private). We use this information to communicate important updates and required actions about your projects.</li> </ul>"},{"location":"Dashboard/Dashboard/#manage-projects","title":"Manage Projects","text":""},{"location":"Dashboard/Dashboard/#creating-a-project","title":"Creating a Project","text":"<p>After logging in for the first time, you'll be greated with a page that allows you to create a new project by signing up for your preferred plan.</p> Info <p>The payment is entirely handled through Stripe. We do not store or have access to your payment details at any time. After paying and creating a project you can manage your subscription at any time through the Manage Subscription navigation link.</p> <p>When signing up for a new plan, a new project is created add added to your list of projects. You can create a new project, with your preferred plan, using the Create New Project button.</p> <p>Each project includes two instances of the ETOPay services:</p> <ol> <li>A <code>test</code> instance used for testing during integration and development.</li> <li>A <code>live</code> instance used for the actual production usage.</li> </ol> <p>After creating a project, follow the Setup Guide shown on the Project Details page to perform the required one-time setup of the Keycloak administrator account that you will use to manage your end-users.</p>"},{"location":"Dashboard/Dashboard/#managing-a-project","title":"Managing a Project","text":"<p>Selecting a project brings you to the Project Details page. Using the toggle in the lower left corner you can select between the <code>test</code> and the <code>live</code> instance. For each instance, you can see statistics about the number of Montly Active Wallets (MAWs) and the number of purchases that have been performed on your instance. Using the navigation on the left side you can also visit the following pages:</p> <ul> <li>Project Details: The main page with statistics and information about your project, including the Setup Guide.</li> <li>User Management: Once your instance is created, you can use this link to manage your users in Keycloak.</li> <li>Purchases: Coming soon: Here you can inspect the purchases that were performed through your instance.</li> <li>Manage Subscription: This link will take you to Stripe to manage your subscription details.</li> <li>Project Settings: Here you can manage settings about your project instance. This has three tabs:<ul> <li>General: General settings like project name and description. This is also where you can archive your project.</li> <li>Wallet: Here you see the list of pre-configured networks we support. In the future you will be able to add your own here.</li> <li>Secrets: This is where you configure secrets for integrating with KYC providers.</li> </ul> </li> </ul>"},{"location":"Dashboard/Dashboard/#retrieving-configuration","title":"Retrieving Configuration","text":"<p>To retrieve the configuration needed for the SDK, go to the Project Details page of your project. Under Setup Guide you will find a template configuration JSON that you can use to initialize the SDK. See also Configuration for details on configuring the SDK.</p>"},{"location":"Dashboard/Dashboard/#configuring-secrets","title":"Configuring Secrets","text":"<p>To use any of the supported KYC providers for enabling Know Your Customer (KYC) on your instance, visit the Secrets tab under Project Settings. On this page, you can enter your access credentials for the respective provider. Note that you need to do this for the <code>live</code> and <code>test</code> instance separately. If you need to rotate the credentials you can update them at any time, but you need to provide all values every time you save.</p> Info <p>The secret values you enter are write-only. Thus there is no way to retrieve the secret values once they are saved. Hence the text inputs will stay empty when the page is refreshed even when values are stored.</p>"},{"location":"Installing%20the%20SDK/Installation/","title":"Installation","text":"<p>For installing the SDK, follow the steps detailed in the quickstart repositories for each ecosystem. Currently the SDK supports the following languages/stacks:</p> Language Quickstart Repository Rust @ETOSPHERES-Labs/etopay-sdk-quickstart-rs Java (including Android) @ETOSPHERES-Labs/etopay-sdk-quickstart-java Swift (iOS and MacOS) @ETOSPHERES-Labs/etopay-sdk-quickstart-swift JavaScript / TypeScript (Browser and Node) @ETOSPHERES-Labs/etopay-sdk-quickstart-ts <p>Further support for other languages &amp; ecosystems can be requested to the SDK team by contacting the maintainers of this document or reaching out directly to us @ ETOSPHERES Labs GmbH.</p>"},{"location":"SDK%20Configuration/Configuration/","title":"Configuring the SDK","text":"<p>The ETOPay SDK needs to be configured correctly for secure and functional usage. Misconfiguration might lead to potential information leaks as well as bad end-user experience.</p>"},{"location":"SDK%20Configuration/Configuration/#static-configuration","title":"Static Configuration","text":"<p>The static configuration is provided by passing a JSON formatted string to the SDK using the <code>set_config</code> function. It has the following format, whose fields are described in the sections below.</p> <pre><code>{\n    \"auth_provider\": \"&lt;authentication provider name&gt;\",\n    \"backend_url\": \"&lt;valid URL to the backend API&gt;\",\n    \"storage_path\": \"/path/to/valid/folder\",\n    \"log_level\": \"info\"\n}\n</code></pre> Info <p>The configuration is usually provided by the dashboard when creating a new project.</p>"},{"location":"SDK%20Configuration/Configuration/#auth-provider","title":"Auth Provider","text":"<p>The value of the auth provider is related to the Keycloak realm created for you when you create a new project in the dashboard.</p> Info <p>The control of the client credentials, the flows used to fetch the JWT as well as the entire user management including user registration, email verification and user settings is out of scope for ETOPay backend and SDK. This should be managed by applications using the SDK themselves.</p> <p>Every time the OAuth client refreshes or fetches a new access token for the user, the access token can be updated in the SDK using the <code>refresh_access_token</code> function.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(\"...\").unwrap();\n\n    sdk.refresh_access_token(Some(\"access_token\")).await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.refreshAccessToken(\"accessToken\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport ETOPaySdk\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.refreshAccessToken(access_token: \"access_token\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.refreshAccessToken(\"access_token\");\n</code></pre> <p>Warning</p> <p>The SDK is not responsible for refreshing the access token. Neither does it have the credentials, nor a way to obtain credentials for refreshing an access token for the user. This is the responsibility of the client application integrating the SDK. The refresh_access_token function should not be confused with refresh_token and should not be passed the value of refresh_token. The function needs the value of a valid access_token as a string. For more information about how to obtain an access token using OAuth2, see <sup>1</sup>.</p>"},{"location":"SDK%20Configuration/Configuration/#configuring-the-backend","title":"Configuring the backend","text":"<p>The <code>backend_url</code> is the URL to the ETOPay backend system. Depending on if you are using the live or the test instance, the values are the following:</p> <ul> <li>Live: <code>https://api-etopay.etospheres.com</code></li> <li>Test: <code>https://api-test-etopay.etospheres.com</code></li> </ul>"},{"location":"SDK%20Configuration/Configuration/#configuring-the-storage-path-prefix","title":"Configuring the storage path prefix","text":"<p>For all platforms, except for when using the TypeScript/Javascript bindings, it is mandatory that the application has access to a file system where it is allowed read and write files and directories and sub-directories. This (existing) folder is specified as the <code>strorage_path</code> field in the configuration and accepts both releative and absolute paths. Absolute paths are, however, preferred and recommended.</p> Tip <p>It is recommended to use a path where only the application has file system rights. Allowing access to other applications is a potential security risk and may incur loss of funds for end-users.</p> Tip <p>For use in Android applications, it is important to extract the path where the app has permissions to create files and directories and use it as the storage path. This is generally something like <code>\\data\\data\\org.example.app\\</code> if the application package is <code>org.example.app</code>.</p>"},{"location":"SDK%20Configuration/Configuration/#logging-in-the-sdk-and-validating-configuration","title":"Logging in the SDK and validating configuration","text":"<p>Whenever the SDK is configured, the logger is automatically initialized. For all platforms except TypeScript/Javascript, whenever a valid log level is specified in the <code>log_level</code> field, the logger is initialized to append log messages to a <code>etopay_sdk.log</code> file in the specified <code>storage_path</code> folder. The different log levels that can be set for the logger are: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> and allow for fine-tuning the amount of log messages that are generated. A value of <code>off</code> can also be specified to disable logging completely. It is important and recommended to enable the logger since this information can be exported and analyzed during testing and integration, which can help diagnose any issues.</p>"},{"location":"SDK%20Configuration/Configuration/#complete-example","title":"Complete example","text":"<p>For a complete example of how to setup and configure the SDK before using any of its module functions, please see Example 0. Shared Setup Code.</p> <ol> <li> <p>The following information links could be used as reference for OAuth2.0 and OpenID Connect</p> <p>OAuth 2.0 Official Website</p> <p>OAuth 2.0 RFC</p> <p>OAuth 2.0 Simplified</p> <p>OAuth 2.0 Playground</p> <p>OpenID Connect Official Website</p> <p>OpenID Connect RFC</p> <p>OpenID Connect Playground</p> <p>OpenID Connect Introduction \u21a9</p> </li> </ol>"},{"location":"SDK%20Examples/Examples/","title":"Examples","text":"<p>The ETOPay SDK is built in <code>rust</code>. It is primarily an implementation of the various interfaces for managing users, wallets, on-boarding of users through KYC (Know Your Customer) processes, payment methods and listing usage information. The flows discussed in this document show examples using the rust language. For examples related to the specific language, refer to the corresponding pages.</p> <p>The ETOPay SDK can be used only if the following pre-requisites have been fulfilled and the information resulting from these conditions is available:</p> <ul> <li>Oauth2.0 Identity and Access Management Provider is configured correctly,</li> <li>The backend base URL of the ETOPay system is known,</li> <li>The path to a certain file storage is available, where the application has read/write rights to create, modify and delete files related to the SDK like log files, local key-value DBs, and wallet files.</li> </ul> <p>Once this information is available, the SDK can be instantiated and the basic functions can be used.</p> <p>The examples shows the usage of the SDK in rust for creating a user. The user credentials are taken from the environment but could also be easily a user input.</p> <p>The environment configuration to <code>Development</code> attaches the SDK to the development backend of ETOPay automatically. It also configures the authentication provider correctly with the one used by the development team internally. This configuration is used by ETOPay developers and is only restricted to the users controlled by the identity provider configured for ETOPay internal testing.</p>"},{"location":"SDK%20Examples/Examples/#0-shared-setup-code","title":"0. Shared Setup Code","text":"RustJavaSwiftJS/TS <pre><code>use etopay_sdk::{\n    core::{Config, Sdk},\n    types::newtypes::{AccessToken, EncryptionPin, PlainPassword},\n};\nuse std::path::Path;\nuse testing::{CleanUp, USER_SATOSHI};\n\npub async fn init_sdk() -&gt; (Sdk, CleanUp) {\n    dotenvy::dotenv().ok();\n\n    // for the examples we want logs to go to the console for easier troubleshooting\n    env_logger::builder().filter_level(log::LevelFilter::Info).init();\n\n    let user = &amp;USER_SATOSHI;\n\n    let cleanup = CleanUp::default();\n\n    let backend_url = std::env::var(\"EXAMPLES_BACKEND_URL\")\n        .expect(\"EXAMPLES_BACKEND_URL environment variable need to be set to run the examples\");\n\n    // construct the config to use for the SDK\n    let config = Config {\n        backend_url: backend_url.parse().expect(\"EXAMPLES_BACKEND_URL must be a valid URL\"),\n        path_prefix: Path::new(&amp;cleanup.path_prefix).into(),\n        auth_provider: \"standalone\".to_string(),\n        log_level: log::LevelFilter::Debug,\n    };\n    let mut sdk = Sdk::new(config).expect(\"should not fail to initialize sdk\"); // set the backend url if the environment variable is set\n\n    // generate access token\n    let access_token = testing::get_access_token(&amp;user.username, &amp;user.password)\n        .await\n        .access_token;\n    let access_token = AccessToken::try_from(access_token).unwrap();\n    sdk.refresh_access_token(Some(access_token)).await.unwrap();\n\n    (sdk, cleanup)\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.github.cdimascio.dotenv.Dotenv;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport java.nio.file.Path;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class utils {\n    public static String USERNAME_SATOSHI = \"satoshi\";\n    public static String PIN = \"1234\";\n    public static String NEW_PIN = \"4321\";\n    public static String USERNAME_ARCHIVEME = \"archiveme\";\n    public static String USERNAME_HANS48 = \"hans48\";\n\n    public static ETOPaySdk initSdk(String username) {\n        ETOPaySdk sdk = new ETOPaySdk();\n\n        // config sdk\n        try {\n            // on CI we want to store the logs as artifacts, so we force the location\n            Path directory;\n            if (getEnvVariable(\"CI\") != null) {\n                Path path = FileSystems.getDefault().getPath(\"logs\");\n                Files.createDirectories(path);\n                directory = Files.createTempDirectory(path, \"etopay_examples\");\n            } else {\n                directory = Files.createTempDirectory(\"etopay_examples\");\n            }\n\n            System.out.println(\"Setting storage path to temporary directory: \" + directory.toString());\n\n            String url = getEnvVariable(\"EXAMPLES_BACKEND_URL\");\n\n            sdk.setConfig(\"\"\"\n                    {\n                        \"backend_url\": \"%s\",\n                        \"storage_path\": \"%s\",\n                        \"log_level\": \"info\",\n                        \"auth_provider\": \"standalone\"\n                    }\n                    \"\"\".formatted(url, directory.toString()));\n\n            System.out.println(\"SDK environment set to development and validated.\");\n\n            // get the access token\n            String access_token = generateAccessToken(username);\n            sdk.refreshAccessToken(access_token);\n            System.out.println(\"retrieved access token\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to initialize SDK\", e);\n        }\n\n        return sdk;\n    }\n\n    // Enum with possible error cases which might happen during the generation of\n    // the access token call.\n    enum TokenError {\n        MISSING_ENVIRONMENT_VARIABLE,\n        INVALID_URL,\n        PARSING_ERROR,\n        ACCESS_TOKEN_NOT_FOUND\n    }\n\n    // Generate an access token by making a call to the KC API\n    public static String generateAccessToken(String username) throws IOException {\n\n        // get from env vars\n        String kcURL = getEnvVariable(\"KC_URL\");\n        String kcRealm = getEnvVariable(\"KC_REALM\");\n        String clientId = getEnvVariable(\"KC_CLIENT_ID\");\n        String clientSecret = getEnvVariable(\"KC_CLIENT_SECRET\");\n        String password = getEnvVariable(\"PASSWORD\");\n\n        if (kcURL == null || kcRealm == null || clientId == null || clientSecret == null || password == null) {\n            throw new RuntimeException(TokenError.MISSING_ENVIRONMENT_VARIABLE.name());\n        }\n\n        String urlString = kcURL + \"/realms/\" + kcRealm + \"/protocol/openid-connect/token\";\n        @SuppressWarnings(\"deprecation\")\n        URL url = new URL(urlString);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        // Construct body parameters\n        Map&lt;String, String&gt; bodyParameters = new HashMap&lt;&gt;();\n        bodyParameters.put(\"grant_type\", \"password\");\n        bodyParameters.put(\"scope\", \"profile email openid\");\n        bodyParameters.put(\"client_id\", clientId);\n        bodyParameters.put(\"client_secret\", clientSecret);\n        bodyParameters.put(\"username\", username);\n        bodyParameters.put(\"password\", password);\n\n        StringBuilder postData = new StringBuilder();\n        for (Map.Entry&lt;String, String&gt; param : bodyParameters.entrySet()) {\n            if (postData.length() != 0)\n                postData.append('&amp;');\n            postData.append(param.getKey());\n            postData.append('=');\n            postData.append(param.getValue());\n        }\n        byte[] postDataBytes = postData.toString().getBytes(\"UTF-8\");\n\n        con.setDoOutput(true);\n        con.getOutputStream().write(postDataBytes);\n\n        // Read response\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            // Parse JSON response using Jackson ObjectMapper\n            InputStream inputStream = con.getInputStream();\n            ObjectMapper mapper = new ObjectMapper();\n            JsonNode jsonResponse = mapper.readTree(inputStream);\n\n            // Check if access_token exists in JSON response\n            if (jsonResponse.has(\"access_token\")) {\n                // System.out.println(jsonResponse.get(\"access_token\").asText());\n                return jsonResponse.get(\"access_token\").asText();\n            } else {\n                throw new RuntimeException(TokenError.ACCESS_TOKEN_NOT_FOUND.name());\n            }\n        } else {\n            throw new RuntimeException(\"Failed to get access token: \" + responseCode);\n        }\n    }\n\n    public static String getEnvVariable(String varName) {\n        // Check if running in CI environment\n        if (System.getenv(\"CI\") != null) {\n            // Use CI environment variables directly\n            return System.getenv(varName);\n        } else {\n            // Load environment variables from .env file for local development\n            Dotenv dotenv = Dotenv.configure().load();\n            return dotenv.get(varName);\n        }\n    }\n}\n</code></pre> <pre><code>import ETOPaySdk\nimport Foundation\n\n// Struct to hold environment variables for examples\npublic struct Environment {\n    public let username: String\n    public let password: String\n    public let pin: String\n    public let mnemonic: String\n\n    public init() {\n        guard\n            let username = ProcessInfo.processInfo.environment[\"USERNAME\"],\n            let password = ProcessInfo.processInfo.environment[\"PASSWORD\"],\n            let mnemonic = ProcessInfo.processInfo.environment[\"MNEMONIC\"]\n        else {\n            fatalError(\"Missing environment variables\")\n        }\n\n        self.username = username\n        self.password = password\n        self.pin = \"1234\"\n        self.mnemonic = mnemonic\n    }\n}\n\n// Helper function to access env variables\npublic func getEnvironment() -&gt; Environment {\n    return Environment()\n}\n\n//  Create sdk instance and set env\npublic func initSdk(username: String, password: String) async throws -&gt; ETOPaySdk {\n    // remove user and wallet generated files\n    cleanup(atPaths: [\"sdk-user.db\", \"wallets\"])\n\n    let url = ProcessInfo.processInfo.environment[\"EXAMPLES_BACKEND_URL\"]!\n\n    // initialize the etopay sdk\n    let sdk = ETOPaySdk()\n\n    // set the sdk config and validate it\n    try await sdk.setConfig(\n        \"\"\"\n        {\n          \"backend_url\": \"\\(url)\",\n          \"storage_path\": \".\",\n          \"log_level\": \"info\",\n          \"auth_provider\": \"standalone\"\n        }\n        \"\"\")\n\n    // get the access token\n    let access_token = try await generateAccessToken(username: username, password: password)\n    try await sdk.refreshAccessToken(access_token)\n    print(\"retrieved access token\")\n\n    return sdk\n}\n\n// Enum with possible error cases which might happen during the generation of the access token call.\nenum TokenError: Error {\n    case missingEnvironmentVariable(String)\n    case invalidURL\n    case parsingError(String)\n    case accessTokenNotFound\n}\n\n// Struct to get the access token from the response\nstruct TokenResponse: Codable {\n    let accessToken: String\n}\n\n// Generate an access token by making a call to the KC API. This is mirroring the `hello.http` endpoint\nfunc generateAccessToken(username: String, password: String) async throws -&gt; String {\n\n    // access environment variables\n    guard\n        let kcURL = ProcessInfo.processInfo.environment[\"KC_URL\"],\n        let kcRealm = ProcessInfo.processInfo.environment[\"KC_REALM\"],\n        let clientId = ProcessInfo.processInfo.environment[\"KC_CLIENT_ID\"],\n        let clientSecret = ProcessInfo.processInfo.environment[\"KC_CLIENT_SECRET\"]\n    else {\n        throw TokenError.missingEnvironmentVariable(\"One or more environment variables are missing\")\n    }\n\n    let urlString = \"\\(kcURL)/realms/\\(kcRealm)/protocol/openid-connect/token\"\n    guard let url = URL(string: urlString) else {\n        throw TokenError.invalidURL\n    }\n\n    var request = URLRequest(url: url)\n    request.httpMethod = \"POST\"\n    request.setValue(\"application/x-www-form-urlencoded\", forHTTPHeaderField: \"Content-Type\")\n\n    // Construct body parameters\n    let bodyParameters = [\n        \"grant_type\": \"password\",\n        \"scope\": \"profile email openid\",\n        \"client_id\": clientId,\n        \"client_secret\": clientSecret,\n        \"username\": username,\n        \"password\": password,\n    ]\n    request.httpBody =\n        bodyParameters\n        .map { \"\\($0.key)=\\($0.value)\" }\n        .joined(separator: \"&amp;\")\n        .data(using: .utf8)\n\n    let (data, _) = try await URLSession.shared.data(for: request)\n\n    let jsonString = String(data: data, encoding: .utf8)\n    guard let jsonData = jsonString?.data(using: .utf8) else {\n        throw TokenError.parsingError(\"failed to parse json data from string\")\n    }\n\n    do {\n        // Parse the JSON data\n        if let json = try JSONSerialization.jsonObject(with: jsonData, options: [])\n            as? [String: Any],\n            let accessToken = json[\"access_token\"] as? String\n        {\n            return accessToken\n        } else {\n            throw TokenError.accessTokenNotFound\n        }\n    } catch _ {\n        throw TokenError.parsingError(\"failed to serialize json data\")\n    }\n}\n\n// cleanup\nfunc cleanup(atPaths paths: [String]) {\n    let fileManager = FileManager.default\n\n    for path in paths {\n        do {\n            // Check if the file or directory exists\n            if fileManager.fileExists(atPath: path) {\n                // Remove the file or directory\n                try fileManager.removeItem(atPath: path)\n            } else {\n                print(\"File or directory does not exist: \\(path). Moving on ..\")\n            }\n        } catch {\n            print(\"Error removing file or directory at \\(path): \\(error)\")\n        }\n    }\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg\";\nimport * as dotenv from 'dotenv';\nimport axios from 'axios';\nimport { LocalStorage } from \"node-localstorage\";\n\nexport async function initSdk(username: string) {\n    dotenv.config();\n\n    // setup localStorage to use a file-based mock version\n    globalThis.window = { localStorage: new LocalStorage('./local-storage') } as any;\n\n    // make sure the localStorage is clear to run each example in isolation\n    try {\n        window.localStorage.clear();\n    } catch (e) {\n        console.log(\"Could not clear local storage: \", e);\n    }\n\n    console.log(\"Starting SDK initialization...\");\n\n    const sdk = new wasm.ETOPaySdk();\n\n    // set the backend url if the environment variable is set\n    let url: string = (process.env.EXAMPLES_BACKEND_URL as string);\n    if (url == undefined) {\n        throw new Error(\"EXAMPLES_BACKEND_URL environment variable must be present\")\n    }\n\n    await sdk.setConfig(`\n    {\n        \"backend_url\": \"${url}\",\n        \"log_level\": \"info\",\n        \"auth_provider\": \"standalone\"\n    }\n    `);\n\n    // Generate access token\n    let access_token = await generateAccessToken(username);\n    await sdk.refreshAccessToken(access_token);\n\n    return sdk;\n}\n\n// Custom error class for handling token errors\nclass TokenError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"TokenError\";\n    }\n\n    static missingEnvironmentVariable(message: string) {\n        return new TokenError(`Missing environment variable: ${message}`);\n    }\n\n    static invalidURL() {\n        return new TokenError('Invalid URL');\n    }\n\n    static parsingError(message: string) {\n        return new TokenError(`Parsing error: ${message}`);\n    }\n\n    static accessTokenNotFound() {\n        return new TokenError('Access token not found');\n    }\n}\n\n// Generate an access token by making a call to the KC API. This is mirroring the `hello.http` endpoint\nasync function generateAccessToken(username: string): Promise&lt;string&gt; {\n    // Access environment variables\n    const kcURL = process.env.KC_URL;\n    const kcRealm = process.env.KC_REALM;\n    const clientId = process.env.KC_CLIENT_ID;\n    const clientSecret = process.env.KC_CLIENT_SECRET;\n    const password = process.env.PASSWORD\n\n    if (!kcURL || !kcRealm || !clientId || !clientSecret || !password) {\n        throw TokenError.missingEnvironmentVariable('One or more environment variables are missing');\n    }\n\n\n    const urlString = `${kcURL}/realms/${kcRealm}/protocol/openid-connect/token`;\n\n    let env_data = {\n        grant_type: 'password',\n        scope: 'profile email openid',\n        client_id: clientId,\n        client_secret: clientSecret,\n        username: username,\n        password: password\n    };\n\n    try {\n        const response = await axios.post(urlString, env_data, {\n            headers: { 'content-type': 'application/x-www-form-urlencoded' },\n\n        });\n\n        const data = response.data;\n        if (data &amp;&amp; data.access_token) {\n            return data.access_token;\n        } else {\n            throw TokenError.accessTokenNotFound();\n        }\n    } catch (error: any) {\n        if (error.response) {\n            // Server responded with a status other than 2xx\n            throw TokenError.parsingError(`Server responded with status ${error.response.status}: ${error.response.statusText}`);\n        } else if (error.request) {\n            // No response was received\n            throw TokenError.invalidURL();\n        } else {\n            // Something happened in setting up the request\n            throw TokenError.parsingError(error.message);\n        }\n    }\n}\n</code></pre>"},{"location":"SDK%20Examples/Examples/#1-create-new-user","title":"1. Create New User","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class CreateNewUser01 {\n\n    public static void main(String[] args) {\n\n        // Initialize SDK\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        try {\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Create new user example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n    } catch let error as RustString {\n        fatalError(\"Create new user example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";// Import the WASM module\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n\n    console.log(\"user created successfully\");\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#2-onboard-user-postident","title":"2. Onboard User Postident","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: This examples does not work unless you do manual postident verification at https://postident-itu.deutschepost.de/testapp\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK and create a new user\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Exit if user is already verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    if is_verified {\n        println!(\"User is already verified, please run the delete_user example first.\");\n        return;\n    }\n\n    // Start KYC verification for postident\n    let new_case_id = sdk.start_kyc_verification_for_postident().await.unwrap();\n    println!(\"New postident user with case: {:#?}\", new_case_id);\n\n    // Do manual postident verification at\n    // https://postident-itu.deutschepost.de/testapp\n    let mut enter = String::new();\n    println!(\"Do postident KYC and hit enter to continue...\");\n    std::io::stdin()\n        .read_line(&amp;mut enter)\n        .expect(\"error: unable to read user input\");\n\n    // Finish KYC verification for postident\n    sdk.update_kyc_status_for_postident(&amp;new_case_id.case_id).await.unwrap();\n\n    // Check that the user is verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    println!(\"IsVerified: {:#?}\", is_verified);\n}\n</code></pre> <pre><code>/**\n    * Do manual postident verification at https://postident-itu.deutschepost.de/testapp\n*/\n\npackage com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class OnboardUserPostident02 {\n\n    public static void main(String[] args) {\n\n        // Initialize SDK\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        try {\n            // create and init new user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // check if user is kyc verified\n            boolean is_verified = sdk.isKycVerified(utils.USERNAME_SATOSHI);\n            if (is_verified == true) {\n                System.out.println(\"User is already verified, please run the delete_user example first.\");\n                return;\n            }\n\n            // Start KYC verification for postident\n            String new_case = sdk.startKycVerificationForPostident();\n            System.out.println(\"New postident user with case: \" + new_case);\n\n            // Do manual postident verification at\n            // https://postident-itu.deutschepost.de/testapp\n\n            // Finish KYC verification for postident\n            sdk.updateKycStatusForPostident(\"new case id\");\n\n            // Check that the user is verified\n            boolean is_verified_after = sdk.isKycVerified(utils.USERNAME_SATOSHI);\n            System.out.println(\"IsVerified: \" + is_verified_after);\n\n        } catch (\n\n        Exception e) {\n            throw new RuntimeException(\"Onboard user postident example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\n// ! Need to do manual verification on postident: https://postident-itu.deutschepost.de/testapp\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Exit if user is already verified\n        let is_verified = try await sdk.isKycVerified(env.username)\n        print(\"is verified: \\(is_verified)\")\n        if is_verified {\n            print(\"User is already verified. No need to delete. Exiting\")\n            return\n        }\n\n        // Start KYC verification for postident\n        let new_user = try await sdk.initKycVerificationForPostident()\n        print(\"New postident user: \\(new_user.case_id.toString()), \\(new_user.case_url.toString())\")\n\n        // Do manual postident verification at https://postident-itu.deutschepost.de/testapp\n\n        // Finish KYC verification for postident\n        try await sdk.updateKycDetailsForPostident(new_user.case_id)\n\n        // Check that the user is verified.\n        // Should be true if the manual verification in postident is done.\n        // Here it will return false.\n        let verified = try await sdk.isKycVerified(env.username)\n        print(\"Is Verified: \\(verified)\")\n\n    } catch let error as RustString {\n        fatalError(\"Onboard user with postident example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>//  Need to do manual verification on postident: https://postident-itu.deutschepost.de/testapp\nimport * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    // Start KYC verification for Postident\n    let response = await sdk.startKycVerificationForPostident();\n    console.log(\"Postident case id:\", response.case_id);\n    console.log(\"Postident case url:\", response.case_url);\n\n    // --&gt; Do Postident KYC process with URL\n\n    // Get KYC details for Postident\n    let caseDetails = await sdk.getKycDetailsForPostident();\n    console.log(\"Case details:\", caseDetails);\n\n    // Update KYC status for Postident\n    await sdk.updateKycStatusForPostident(response.case_id);\n    console.log(\"Case status updated.\");\n\n    // Check if KYC is verified\n    let isVerified = await sdk.isKycVerified(username);\n    console.log(\"IsVerified:\", isVerified);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#4-migrate-wallet-from-mnemonic","title":"4. Migrate Wallet From Mnemonic","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n\n    // Create new wallet\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // use wallet\n    let _address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\nimport com.etospheres.etopay.model.Network;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport java.util.List;\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class MigrateWalletFromMnemonic04 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic = utils.getEnvVariable(\"MNEMONIC\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic);\n            System.out.println(\"Created new wallet from mnemonic.\");\n\n            // fetch networks from backend\n            String networks = sdk.getNetworks();\n\n            List&lt;Network&gt; networksList;\n            try {\n                ObjectMapper objectMapper = new ObjectMapper();\n                networksList = objectMapper.readValue(networks, new TypeReference&lt;List&lt;Network&gt;&gt;() {\n                });\n            } catch (JsonProcessingException e) {\n                throw new RuntimeException(\"Error processing JSON response\", e);\n            }\n\n            Network iotaNetwork = networksList.get(0);\n            // set the network configuration for the wallet\n            sdk.setNetwork(iotaNetwork.key);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Migrate wallet from mnemonic example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport ETOPaySdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")                     \n\n    } catch let error as RustString  {\n        fatalError(\"Migrate wallet from mnemonic example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    // Create new wallet from the mnemonic\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    // fetch networks from backend\n    let networks = await sdk.getNetworks();\n    // set the network configuration for the wallet\n    sdk.setNetwork(networks[0].key);\n\n    // use wallet\n    let _address = await sdk.generateNewAddress(pin);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#5-migrate-wallet-from-backup","title":"5. Migrate Wallet From Backup","text":"RustJavaSwiftJS/TS <pre><code>use etopay_sdk::types::newtypes::PlainPassword;\nmod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Create wallet backup and delete it\n    let backup_password = PlainPassword::try_from_string(\"backup_password\").unwrap();\n    let backup = sdk.create_wallet_backup(&amp;user.pin, &amp;backup_password).await.unwrap();\n    sdk.delete_wallet(&amp;user.pin).await.unwrap();\n\n    // Migrate wallet from backup\n    sdk.create_wallet_from_backup(&amp;user.pin, &amp;backup, &amp;backup_password)\n        .await\n        .unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // use wallet\n    let _address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class MigrateWalletFromBackup05 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // create backup\n            byte[] backup_bytes = sdk.createWalletBackup(utils.PIN, \"backup_password\");\n\n            // delete existing wallet\n            sdk.deleteWallet(utils.PIN);\n            System.out.println(\"deleted existing wallet\");\n\n            // migrate wallet from backup\n            sdk.createWalletFromBackup(utils.PIN, backup_bytes, \"backup_password\");\n            System.out.println(\"wallet restored from backup\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Migrate wallet from backup example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport ETOPaySdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Create backup\n        let backup_password = \"backup_password\"\n        let backup = try await sdk.createWalletBackup(env.pin, backup_password)\n\n        // Delete existing wallet\n        try await sdk.deleteWallet(env.pin)\n        print(\"deleted existing wallet\")\n\n        // Migrate wallet from backup\n        try await sdk.restoreWalletFromBackup(env.pin, backup, backup_password)\n        print(\"wallet restored from backup\")                      \n\n    } catch let error as RustString  {\n        fatalError(\"Migrate wallet from backup example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    // Create new wallet from the mnemonic\n    await sdk.createNewWallet(pin);\n\n    // Create wallet backup and delete it\n    let backup_password = \"backup_password\";\n\n    let backup = await sdk.createWalletBackup(pin, backup_password);\n    await sdk.deleteWallet(pin)\n\n    // Migrate wallet from backup\n    await sdk.createWalletFromBackup(pin, backup, backup_password);\n\n    // fetch networks from backend\n    let networks = await sdk.getNetworks();\n    // set the network configuration for the wallet\n    sdk.setNetwork(networks[0].key);\n\n    // use wallet\n    let _address = await sdk.generateNewAddress(pin);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#6-generate-new-receiver-address","title":"6. Generate New Receiver Address","text":"RustJavaSwiftJS/TS <pre><code>use testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // Generate address\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"Address: {}\", address);\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\nimport com.etospheres.etopay.model.Network;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport java.util.List;\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class GenerateNewAddress06 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic = utils.getEnvVariable(\"MNEMONIC\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic);\n            System.out.println(\"Created and initialized new wallet from mnemonic.\");\n\n            // fetch networks from backend\n            String networks = sdk.getNetworks();\n\n            List&lt;Network&gt; networksList;\n            try {\n                ObjectMapper objectMapper = new ObjectMapper();\n                networksList = objectMapper.readValue(networks, new TypeReference&lt;List&lt;Network&gt;&gt;() {\n                });\n            } catch (JsonProcessingException e) {\n                throw new RuntimeException(\"Error processing JSON response\", e);\n            }\n\n            Network iotaNetwork = networksList.get(0);\n            // set the network configuration for the wallet\n            sdk.setNetwork(iotaNetwork.key);\n\n            // generate receiver address\n            String address = sdk.generateNewAddress(utils.PIN);\n            System.out.println(\"address: \" + address);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Generate new address example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")\n\n        // Fetch networks from backend\n        let networks = try await sdk.getNetworks()\n        try await sdk.setNetwork(networks[0].key())\n        print(\"retrieved available networks and set the network for the wallet\")\n\n        // Generate address\n        let address = try await sdk.generateNewAddress(env.pin)\n        print(\"generated new receiver address: \\(address.toString())\")\n\n    } catch let error as RustString {\n        fatalError(\"Generate new iota address example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    // fetch networks from backend\n    let networks = await sdk.getNetworks();\n    // set the network configuration for the wallet\n    sdk.setNetwork(networks[0].key);\n\n    await sdk.createNewWallet(pin);\n    console.log(\"Wallet initialized!\");\n    let address = await sdk.generateNewAddress(pin);\n    console.log(\"Address:\", address);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#7-get-balance","title":"7. Get Balance","text":"RustJavaSwiftJS/TS <pre><code>use testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // Generate address\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"Address: {}\", address);\n\n    // Get balance\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"Balance: {:?}\", balance);\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\nimport com.etospheres.etopay.model.Network;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport java.util.List;\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class GetBalance07 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic = utils.getEnvVariable(\"MNEMONIC\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic);\n            System.out.println(\"Created and initialized new wallet from mnemonic.\");\n\n            // fetch networks from backend\n            String networks = sdk.getNetworks();\n\n            List&lt;Network&gt; networksList;\n            try {\n                ObjectMapper objectMapper = new ObjectMapper();\n                networksList = objectMapper.readValue(networks, new TypeReference&lt;List&lt;Network&gt;&gt;() {\n                });\n            } catch (JsonProcessingException e) {\n                throw new RuntimeException(\"Error processing JSON response\", e);\n            }\n\n            Network iotaNetwork = networksList.get(0);\n            // set the network configuration for the wallet\n            sdk.setNetwork(iotaNetwork.key);\n\n            // generate receiver address\n            String address = sdk.generateNewAddress(utils.PIN);\n            System.out.println(\"address: \" + address);\n\n            // get balance\n            double balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"balance: \" + balance);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Get balance example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")\n\n        // Fetch networks from backend\n        let networks = try await sdk.getNetworks()\n        try await sdk.setNetwork(networks[0].key())\n        print(\"retrieved available networks and set the network for the wallet\")\n\n        // Generate address\n        let address = try await sdk.generateNewAddress(env.pin)\n        print(\"generated new receiver address: \\(address.toString())\")\n\n        // Get wallet balance\n        let balance = try await sdk.getWalletBalance(env.pin)\n        print(\"balance: \\(balance)\")\n\n    } catch let error as RustString {\n        fatalError(\"Get wallat balance failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    console.log(\"start\");\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    // fetch networks from backend\n    let networks = await sdk.getNetworks();\n    // set the network configuration for the wallet\n    sdk.setNetwork(networks[0].key);\n\n    let address = await sdk.generateNewAddress(pin);\n    console.log(\"Address:\", address);\n\n    let balance = await sdk.getWalletBalance(pin);\n    console.log(\"Balance:\", balance);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#8-create-purchase-request","title":"8. Create Purchase Request","text":"RustJavaSwiftJS/TS <pre><code>use etopay_sdk::types::currencies::CryptoAmount;\nuse rust_decimal_macros::dec;\nuse testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // Generate address\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"Address: {}\", address);\n\n    // Get balance\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"Balance: {:?}\", balance);\n\n    // Create purchase request\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = \"{\\\"imageUrl\\\":\\\"https://httpbin.org/\\\",\\\"imageId\\\":\\\"a846ad10-fc69-4b22-b442-5dd740ace361\\\"}\";\n    let purchase_type = \"CLIK\";\n\n    let amount = CryptoAmount::try_from(dec!(2.0)).unwrap();\n    let purchase_id = sdk\n        .create_purchase_request(\"alice\", amount, product_hash, app_data, purchase_type)\n        .await\n        .unwrap();\n    println!(\"Purchase_id {} \", purchase_id); // print the purchase id to facilitate debugging\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\nimport com.etospheres.etopay.model.Network;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport java.util.List;\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class CreatePurchaseRequest08 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic = utils.getEnvVariable(\"MNEMONIC\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic);\n            System.out.println(\"Created and initialized new wallet from mnemonic.\");\n\n            // fetch networks from backend\n            String networks = sdk.getNetworks();\n\n            List&lt;Network&gt; networksList;\n            try {\n                ObjectMapper objectMapper = new ObjectMapper();\n                networksList = objectMapper.readValue(networks, new TypeReference&lt;List&lt;Network&gt;&gt;() {\n                });\n            } catch (JsonProcessingException e) {\n                throw new RuntimeException(\"Error processing JSON response\", e);\n            }\n\n            Network iotaNetwork = networksList.get(0);\n            // set the network configuration for the wallet\n            sdk.setNetwork(iotaNetwork.key);\n\n            // generate receiver address\n            String address = sdk.generateNewAddress(utils.PIN);\n            System.out.println(\"address: \" + address);\n\n            // get balance\n            double balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"balance: \" + balance);\n\n            // create purchase request\n            // Create purchase request\n            String product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n            String app_data = \"{\\\"imageUrl\\\":\\\"https://httpbin.org/\\\",\\\"imageId\\\":\\\"a846ad10-fc69-4b22-b442-5dd740ace361\\\"}\";\n            String purchase_type = \"CLIK\";\n\n            String purchase_id = sdk.purchaseRequestCreate(\"alice\", 2, product_hash, app_data, purchase_type);\n            System.out.println(\"purchase request id: \" + purchase_id);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Create purchase request example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")\n\n        // Fetch networks from backend\n        let networks = try await sdk.getNetworks()\n        try await sdk.setNetwork(networks[0].key())\n        print(\"retrieved available networks and set the network for the wallet\")\n\n        // Generate address\n        let address = try await sdk.generateNewAddress(env.pin)\n        print(\"generated new receiver address: \\(address.toString())\")\n\n        // Get wallet balance\n        let balance = try await sdk.getWalletBalance(env.pin)\n        print(\"balance: \\(balance)\")\n\n        // Create purchase request\n        let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"\n        let app_data =\n            \"{\\\"imageUrl\\\":\\\"https://httpbin.org/\\\",\\\"imageId\\\":\\\"a846ad10-fc69-4b22-b442-5dd740ace361\\\"}\"\n        let purchase_type = \"CLIK\"\n\n        let purchase_id = try await sdk.createPurchaseRequest(\n            \"alice\", 2, product_hash, app_data, purchase_type)\n        print(\"Purchase Request created: \\(purchase_id.toString())\")\n\n    } catch let error as RustString {\n        fatalError(\"Create purchase request example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import { debug } from \"util\";\nimport * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    let receiver = \"alice\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    // fetch networks from backend\n    let networks = await sdk.getNetworks();\n    // set the network configuration for the wallet\n    sdk.setNetwork(networks[0].key);\n\n    let address = await sdk.generateNewAddress(pin);\n    debug(`Generated new IOTA receiver address: ${address}`);\n    let balance = await sdk.getWalletBalance(pin);\n\n    console.log(\"balance : \", balance);\n\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = JSON.stringify({\n        \"imageUrl\": \"https://httpbin.org/\",\n        \"imageId\": \"a846ad10-fc69-4b22-b442-5dd740ace361\"\n    });\n\n    let purchase_type = \"CLIK\";\n\n    let purchase_id = await sdk.createPurchaseRequest(receiver, 2.0, product_hash, app_data, purchase_type);\n    console.log(\"Purchase ID:\", purchase_id);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#9-onboard-a-user-on-viviswap","title":"9. Onboard a User on Viviswap","text":"RustJavaSwiftJS/TS <pre><code>use etopay_sdk::types::viviswap::{ViviswapVerificationStatus, ViviswapVerificationStep};\nuse fake::{\n    faker::name::{en::LastName, raw::FirstName},\n    locales::EN,\n    Fake,\n};\nuse std::io::Write;\nuse testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: This example will not run until the end because the user already exists in Viviswap db and it will not create a new one.\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK and create a new user\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Exit if user is already verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    if is_verified {\n        println!(\"User is already verified, please run the delete_user example first.\");\n        return;\n    }\n\n    // Start KYC verification for viviswap\n    // The user already exists in viviswap db. Therefore, the test will fail here.\n    let new_user = sdk\n        .start_kyc_verification_for_viviswap(&amp;format!(\"{}@gmail.com\", user.username), true)\n        .await\n        .unwrap();\n    println!(\"New Viviswap user: {:#?}\", new_user);\n\n    // Get KYC status for viviswap\n    let status = sdk.get_kyc_details_for_viviswap().await.unwrap();\n    println!(\"Status: {:#?}\", status);\n\n    // Update KYC status for viviswap\n    let is_individual = Some(true);\n    let is_pep = Some(false);\n    let is_us_citizen = Some(false);\n    let is_regulatory_disclosure = Some(true);\n    let country_of_residence = Some(\"DE\".into());\n    let nationality = Some(\"DE\".to_string());\n    let full_name = Some(format!(\n        \"{} {}\",\n        FirstName(EN).fake::&lt;String&gt;(),\n        LastName().fake::&lt;String&gt;()\n    ));\n    let date_of_birth = Some(\"2001-11-05\".to_string());\n\n    let details = sdk\n        .update_kyc_partially_status_for_viviswap(\n            is_individual,\n            is_pep,\n            is_us_citizen,\n            is_regulatory_disclosure,\n            country_of_residence,\n            nationality,\n            full_name,\n            date_of_birth,\n        )\n        .await\n        .unwrap();\n    println!(\"Details: {:#?}\", details);\n\n    sdk.submit_kyc_partially_status_for_viviswap().await.unwrap();\n\n    // Create a waiting loop that prints a dot every 5 seconds for 30 secounds\n    println!(\"Waiting for KYC verification to complete\");\n    for _ in 0..12 {\n        tokio::time::sleep(tokio::time::Duration::from_secs(6)).await;\n        print!(\".\");\n        std::io::stdout().flush().unwrap();\n        let kyc_details = sdk.get_kyc_details_for_viviswap().await.unwrap();\n        if kyc_details.verified_step == ViviswapVerificationStep::Personal {\n            break;\n        }\n    }\n    println!();\n\n    // Check that the user is verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    println!(\"IsVerified: {:#?}\", is_verified);\n\n    let kyc_details = sdk.get_kyc_details_for_viviswap().await.unwrap();\n    println!(\"KycDetails: {:#?}\", kyc_details);\n    assert!(kyc_details.verification_status == ViviswapVerificationStatus::Unverified);\n    assert!(kyc_details.verified_step == ViviswapVerificationStep::Personal);\n    assert!(kyc_details.submission_step == ViviswapVerificationStep::Identity);\n}\n</code></pre> <pre><code>/**\n    * This example will not run until the end because the user already exists in Viviswap db and it will not create a new one.\n*/\n\npackage com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class OnboardUserViviswap09 {\n\n    public static void main(String[] args) {\n\n        // Initialize SDK\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        try {\n            // create and init new user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // check if user is kyc verified\n            boolean is_verified = sdk.isKycVerified(utils.USERNAME_SATOSHI);\n            if (is_verified == true) {\n                System.out.println(\"User is already verified, please run the delete_user example first.\");\n                return;\n            }\n\n            // Start KYC verification for viviswap\n            // The user already exists in viviswap db. Therefore, the test will fail here.\n            String new_user = sdk\n                    .startViviswapKyc(\"javaexamples@gmail.com\", true);\n            System.out.println(\"New Viviswap user: \" + new_user);\n\n            // Get KYC status for viviswap\n            String details = sdk.getViviswapKyc();\n            System.out.println(\"Viviswap KYC details: \" + details);\n\n        } catch (\n\n        Exception e) {\n            throw new RuntimeException(\"Onboard user viviswap example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\n// Onboard with viviswap example\n// The user already exists in viviswap db. Therefore, the test will fail here.\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Exit if user is already verified\n        let is_verified = try await sdk.isKycVerified(env.username)\n        print(\"is verified: \\(is_verified)\")\n        if is_verified {\n            print(\"User is already verified. No need to delete. Exiting\")\n            return\n        }\n\n        // Start KYC verification for viviswap\n        let new_user = try await sdk.startKycVerificationForViviswap(\n            \"swift_example@gmail.com\", true)\n        print(\"New viviswap user: \\(new_user)\")\n\n        // Get KYC status for viviswap\n        let status = try await sdk.getKycDetailsForViviswap()\n        print(\"Status: \\(status)\")\n\n        // Update KYC status for viviswap\n        var isIndividual: Bool? = true\n        var isPep: Bool? = false\n        var isUsCitizen: Bool? = false\n        var isRegulatoryDisclosure: Bool? = true\n        var countryOfResidence: String? = \"DE\"\n        var nationality: String? = \"DE\"\n        var fullName: String? = \"fake fake\"\n        var dateOfBirth: String? = \"2001-11-05\"\n\n        let details =\n            try await sdk\n            .updateKycPartiallyStatusForViviswap(\n                isIndividual,\n                isPep,\n                isUsCitizen,\n                isRegulatoryDisclosure,\n                countryOfResidence,\n                nationality,\n                fullName,\n                dateOfBirth\n            )\n        print(\"Details: \\(details)\")\n        try await sdk.submitKycPartiallyStatusForViviswap()\n\n        // Create a waiting loop that prints a dot every 5 seconds for 30 seconds\n        print(\"Waiting for KYC verification to complete\")\n        for _ in 0..&lt;12 {\n            sleep(6)\n            print(\".\")\n            fflush(stdout)\n            let kycDetails = try await sdk.getKycDetailsForViviswap()\n            if kycDetails.verified_step == .Personal {\n                break\n            }\n        }\n\n        // Check that the user is verified\n        let isVerified = try await sdk.isKycVerified(env.username)\n        print(\"IsVerified: \\(isVerified)\")\n\n    } catch let error as RustString {\n        fatalError(\"Onboard user with viviswap example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    let is_verified = await sdk.isKycVerified(username)\n\n    if (is_verified) {\n        console.log(\"user is verified\");\n        return;\n    }\n\n    // Start KYC verification for viviswap\n    // The user already exists in viviswap db. Therefore, the test will fail here.\n\n    let newUser = await sdk.startKycVerificationForViviswap(\"wasmtest@gmail.com\", true);\n    console.log(`New viviswap user: ${newUser}`);\n}\n\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#10-verify-pin","title":"10. Verify Pin","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Verify pin\n    sdk.verify_pin(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class VerifyPin10 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // verify pin\n            sdk.pinVerify(utils.PIN);\n            System.out.println(\"Pin verified\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Verify pin example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport ETOPaySdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)        \n        let _ = try await sdk.createNewWallet(env.pin)\n\n        // Verify pin\n        try await sdk.verifyPin(env.pin)\n        print(\"pin verified\")                      \n\n    } catch let error as RustString  {\n        fatalError(\"Verify pin example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    await sdk.verifyPin(pin);\n    console.log(\"Pin verified successfully\");\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#11-reset-pin","title":"11. Reset Pin","text":"RustJavaSwiftJS/TS <pre><code>use etopay_sdk::types::newtypes::EncryptionPin;\nmod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: This examples does not work. It gets stuck. Does not pass or fail.\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Reset pin\n    let new_pin = EncryptionPin::try_from_string(\"123456\").unwrap();\n    sdk.change_pin(&amp;user.pin, &amp;new_pin).await.unwrap();\n\n    // Verify pin\n    sdk.verify_pin(&amp;new_pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class ResetPin11 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create and init new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and init new wallet.\");\n\n            // reset pin\n            sdk.pinReset(utils.PIN, utils.NEW_PIN);\n\n            // verify new pin\n            sdk.pinVerify(utils.NEW_PIN);\n            System.out.println(\"New pin verified\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Reset pin example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport ETOPaySdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n        let new_pin = \"4321\";\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)        \n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Reset pin\n        try await sdk.resetPin(env.pin, new_pin)\n        print(\"pin reseted\")\n\n        // Verify new pin\n        try await sdk.verifyPin(new_pin)\n        print(\"new pin verified\")                     \n\n    } catch let error as RustString  {\n        fatalError(\"Reset pin example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    let new_pin = \"54321\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    await sdk.resetPin(pin, new_pin);\n    console.log(\"Reset pin successful\");\n\n    await sdk.verifyPin(new_pin);\n    console.log(\"new pin verified\");\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#12-change-password","title":"12. Change Password","text":"RustJavaSwiftJS/TS <pre><code>use etopay_sdk::types::newtypes::PlainPassword;\nmod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Change password\n    let new_password = PlainPassword::try_from_string(\"StrongP@ssw0rd\").unwrap();\n    sdk.set_wallet_password(&amp;user.pin, &amp;new_password).await.unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // use wallet\n    let _address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class ChangePassword12 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // change password\n            sdk.setWalletPassword(utils.PIN, \"StrongP@ssw0rd\");\n            System.out.println(\"Password changed\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Change password example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n        let new_password = \"StrongP@ssw0rd\"\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Change password\n        try await sdk.setWalletPassword(env.pin, new_password)\n        print(\"password changed\")\n\n    } catch let error as RustString {\n        fatalError(\"Change password example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    let new_pin = \"54321\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    let new_password = \"new password\"\n    await sdk.setWalletPassword(pin, new_password);\n    console.log(\"change password successful\");\n\n    // fetch networks from backend\n    let networks = await sdk.getNetworks();\n    // set the network configuration for the wallet\n    sdk.setNetwork(networks[0].key);\n\n    let _address = await sdk.generateNewAddress(pin);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#13-send-amount","title":"13. Send Amount","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse rust_decimal_macros::dec;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n    let (mut sdk, _cleanup) = init_sdk().await;\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // Generate new address\n    let recipient_address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"address: {recipient_address}, balance: {balance:?}\");\n\n    // Send amount\n    let amount = dec!(2.0).try_into().unwrap();\n    let data = Some(\"test\".to_string().into_bytes());\n    // estimate gas\n    let estimate = sdk\n        .estimate_gas(&amp;user.pin, &amp;recipient_address, amount, data.clone())\n        .await\n        .unwrap();\n\n    println!(\"Estimated gas: {estimate:?}\");\n\n    let tx_id = sdk\n        .send_amount(&amp;user.pin, &amp;recipient_address, amount, data)\n        .await\n        .unwrap();\n\n    println!(\"Success with transaction id: {tx_id}\");\n\n    let details = sdk.get_wallet_tx(&amp;user.pin, &amp;tx_id).await.unwrap();\n    println!(\"Details:\\n{:#?}\", details);\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\nimport com.etospheres.etopay.model.Network;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport java.util.List;\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class SendAmount13 {\n\n    public static void main(String[] args) {\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic = utils.getEnvVariable(\"MNEMONIC\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic);\n            System.out.println(\"Created and initialized new wallet from mnemonic.\");\n\n            // fetch networks from backend\n            String networks = sdk.getNetworks();\n\n            List&lt;Network&gt; networksList;\n            try {\n                ObjectMapper objectMapper = new ObjectMapper();\n                networksList = objectMapper.readValue(networks, new TypeReference&lt;List&lt;Network&gt;&gt;() {\n                });\n            } catch (JsonProcessingException e) {\n                throw new RuntimeException(\"Error processing JSON response\", e);\n            }\n\n            Network iotaNetwork = networksList.get(0);\n            // set the network configuration for the wallet\n            sdk.setNetwork(iotaNetwork.key);\n\n            // generate receiver address\n            String address = sdk.generateNewAddress(utils.PIN);\n            System.out.println(\"address: \" + address);\n\n            // get balance\n            double balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"balance: \" + balance);\n\n            // send amount\n            String tx_id = sdk.sendAmount(utils.PIN, address.toString(), 1, \"java bindings test\".getBytes());\n            System.out.println(\"send amount of 1 with transaction \" + tx_id);\n\n            // get new balance\n            double new_balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"new balance: \" + new_balance);\n\n            // print the details\n            String details = sdk.getWalletTransaction(utils.PIN, tx_id);\n            System.out.println(\"details: \" + details);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Send amount example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")\n\n        // Fetch networks from backend\n        let networks = try await sdk.getNetworks()\n        try await sdk.setNetwork(networks[0].key())\n        print(\"retrieved available networks and set the network for the wallet\")\n\n        // Generate address\n        let address = try await sdk.generateNewAddress(env.pin)\n        print(\"generated new receiver address: \\(address.toString())\")\n\n        // Get wallet balance\n        let balance = try await sdk.getWalletBalance(env.pin)\n        print(\"balance: \\(balance)\")\n\n        // Send amount\n        let message = \"swift bindings test\"\n\n        // convert to a RustVec by copying over all values\n        let rustVec = RustVec&lt;UInt8&gt;.init()\n        for byte in message.utf8 {\n            rustVec.push(value: byte)\n        }\n\n        let bytes: [UInt8] = Array(message.utf8)\n        let tx_id = try await sdk.sendAmount(env.pin, address.toString(), 1, rustVec)\n        print(\"sent amount of 1 on transaction \\(tx_id.toString())\")\n\n        // Get new balance\n        let new_balance = try await sdk.getWalletBalance(env.pin)\n        print(\"new balance: \\(new_balance)\")\n\n        // Get the details (wrap env.pin in RustString to make sure parameters have the same type (they share same generic type))\n        let details = try await sdk.getWalletTransaction(RustString(env.pin), tx_id)\n        print(\"tx details status: \\(details.status().toString())\")\n        print(\"tx details amount: \\(details.amount())\")\n        print(\"tx details receiver: \\(details.receiver().toString())\")\n        print(\"tx details block_id: \\(details.block_id().toString())\")\n\n\n    } catch let error as RustString {\n        fatalError(\"Send amount example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    // fetch networks from backend\n    let networks = await sdk.getNetworks();\n    // set the network configuration for the wallet\n    sdk.setNetwork(networks[0].key);\n\n    let recipient_address = await sdk.generateNewAddress(pin);\n    console.log(\"address\", recipient_address);\n\n    let balance_before = await sdk.getWalletBalance(pin);\n    console.log(\"balance before sending amount\", balance_before);\n\n    const data = new TextEncoder().encode(\"wasm example\");\n    let tx_id = await sdk.sendAmount(pin, recipient_address, 1.0, data);\n    console.log(\"sent amount with transaction\", tx_id);\n\n    let balance_after = await sdk.getWalletBalance(pin);\n    console.log(\"balance after sending amount\", balance_after);\n\n    let details = await sdk.getWalletTransaction(pin, tx_id);\n    console.log(\"transaction details: \", details);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#14-get-exchange-rate","title":"14. Get Exchange Rate","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // Get exchange rate\n    let exchange_rate = sdk.get_exchange_rate().await.unwrap();\n    println!(\"Exchange rate: {}\", exchange_rate);\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\nimport com.etospheres.etopay.model.Network;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport java.util.List;\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class GetExchangeRate14 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        try {\n\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // fetch networks from backend\n            String networks = sdk.getNetworks();\n\n            List&lt;Network&gt; networksList;\n            try {\n                ObjectMapper objectMapper = new ObjectMapper();\n                networksList = objectMapper.readValue(networks, new TypeReference&lt;List&lt;Network&gt;&gt;() {\n                });\n            } catch (JsonProcessingException e) {\n                throw new RuntimeException(\"Error processing JSON response\", e);\n            }\n\n            Network iotaNetwork = networksList.get(0);\n            // set the network configuration for the wallet\n            sdk.setNetwork(iotaNetwork.key);\n\n            // get exchange rate\n            double exchange_rate = sdk.getExchangeRate();\n            System.out.println(\"Exchange rate: \" + exchange_rate);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Get exchange rate example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Fetch networks from backend\n        let networks = try await sdk.getNetworks()\n        try await sdk.setNetwork(networks[0].key())\n        print(\"retrieved available networks and set the network for the wallet\")\n\n        let exchange_rate = try await sdk.getExchangeRate()\n        print(\"exchange rate: \\(exchange_rate)\")\n\n    } catch let error as RustString {\n        fatalError(\"Get exchange rate example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    // fetch networks from backend\n    let networks = await sdk.getNetworks();\n    // set the network configuration for the wallet\n    sdk.setNetwork(networks[0].key);\n\n    let course = await sdk.getExchangeRate();\n    console.log(course);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#16-get-purchase-list","title":"16. Get Purchase List","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Get tx list\n    let tx_list = sdk.get_tx_list(0, 10).await.unwrap();\n    tx_list\n        .txs\n        .iter()\n        .for_each(|tx| println!(\"tx reference id: {:?}\", tx.reference_id));\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class GetTxList16 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // get tx list\n            String tx_list = sdk.txList(0, 10);\n            System.out.println(\"tx list: \" + tx_list);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Get tx list example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport ETOPaySdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Get tx list\n        let tx_list = try await sdk.getTransactionList(0, 10)\n        // need to properly print the list\n        print(\"Tx list: \\(tx_list)\")             \n\n    } catch let error as RustString  {\n        fatalError(\"Get transaction list example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\n\nasync function main() {\n    let username = \"satoshi\";\n    let start = 0;\n    let limit = 10;\n    let pin = \"1234\"; // Define the PIN\n    const sdk = await initSdk(username); // Initialize the SDK\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username); //Creating a new user \n    await sdk.initializeUser(username); // Initialize the user\n\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic); // Initialize the wallet\n    console.log(\"Wallet initialized!\");\n\n    let transactions = await sdk.getTransactionList(0, 10);  // Get the transaction list\n    console.log(\"Transactions: \" + JSON.stringify(transactions));\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#18-delete-user","title":"18. Delete User","text":"RustJavaSwiftJS/TS <pre><code>use etopay_sdk::types::newtypes::AccessToken;\nmod utils;\nuse testing::USER_ARCHIVEME;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: Do not run this example with user `satoshi` because it will then be unverified and it will affect other examples / tests.\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_ARCHIVEME).clone().into();\n\n    // the `init_sdk()` function generates an access token for `satoshi`.\n    // in this example we use `archiveme` user. Therefore, we generate a new access token for the `archiveme` user.\n    let access_token = testing::get_access_token(&amp;user.username, user.password.as_str())\n        .await\n        .access_token;\n    let access_token = AccessToken::try_from(access_token).unwrap();\n    sdk.refresh_access_token(Some(access_token)).await.unwrap();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Delete user\n    sdk.delete_user(Some(&amp;user.pin)).await.unwrap();\n    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class DeleteUser18 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_ARCHIVEME);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_ARCHIVEME);\n            sdk.initializeUser(utils.USERNAME_ARCHIVEME);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create and init new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // Delete user and wallet\n            sdk.deleteUser(utils.PIN);\n\n            // check verification after deletion. Should be false\n            boolean verified = sdk.isKycVerified(utils.USERNAME_ARCHIVEME);\n            System.out.println(\"is verified: \" + verified);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Delete user example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport ETOPaySdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n        let username_archive = ProcessInfo.processInfo.environment[\"ARCHIEVEME\"]!;\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: username_archive, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(username_archive)\n        print(\"created new user: \\(username_archive)\")\n        try await sdk.initUser(username_archive)\n        print(\"initialized new user: \\(username_archive)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        print(\"deleting user and wallet\")\n        try await sdk.deleteUser(env.pin)\n\n        // check verification after deletion. Should be false\n        let verified = try await sdk.isKycVerified(username_archive)\n        print(\"is verified: \\(verified)\")\n\n    } catch let error as RustString  {\n        fatalError(\"Delete user example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"archiveme\";\n    let pin = \"1234\";\n\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n    await sdk.deleteUser(pin);\n    console.log(\"user deleted_successfully\");\n}\n\nexport { main }\n</code></pre>"},{"location":"SDK%20Examples/Examples/#19-get-wallet-transaction-list","title":"19. Get Wallet Transaction List","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // Get wallet tx list\n    let wallet_tx_list = sdk.get_wallet_tx_list(&amp;user.pin, 0, 10).await.unwrap();\n    wallet_tx_list\n        .transactions\n        .iter()\n        .for_each(|tx| println!(\"Wallet transaction id: {:?}\", tx.transaction_id));\n}\n</code></pre> <pre><code>package com.etospheres.etopay.examples;\n\nimport com.etospheres.etopay.ETOPaySdk;\nimport com.etospheres.etopay.model.Network;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport java.util.List;\nimport com.etospheres.etopay.ETOPaySdk;\n\npublic class GetWalletTxList19 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        ETOPaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setWalletPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // fetch networks from backend\n            String networks = sdk.getNetworks();\n\n            List&lt;Network&gt; networksList;\n            try {\n                ObjectMapper objectMapper = new ObjectMapper();\n                networksList = objectMapper.readValue(networks, new TypeReference&lt;List&lt;Network&gt;&gt;() {\n                });\n            } catch (JsonProcessingException e) {\n                throw new RuntimeException(\"Error processing JSON response\", e);\n            }\n\n            Network iotaNetwork = networksList.get(0);\n            // set the network configuration for the wallet\n            sdk.setNetwork(iotaNetwork.key);\n\n            // get wallet_tx_list\n            String wallet_tx_list = sdk.getWalletTransactionList(utils.PIN, 0, 10);\n            System.out.println(\"wallet tx list: \" + wallet_tx_list);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Get wallet tx list example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport ETOPaySdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Fetch networks from backend\n        let networks = try await sdk.getNetworks()\n        try await sdk.setNetwork(networks[0].key())\n        print(\"retrieved available networks and set the network for the wallet\")\n\n        // Get wallet tx list\n        let tx_list = try await sdk.getWalletTransactionList(env.pin, 0, 10)\n        // need to properly print the list\n        print(\"Tx list: \\(tx_list)\")\n\n    } catch let error as RustString {\n        fatalError(\"Get wallet transaction list example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\nimport { initSdk } from './utils';\n\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\"; // Define the PIN\n\n    const sdk = await initSdk(username); // Initialize the SDK\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username); //Creating a new user \n    await sdk.initializeUser(username); // Initialize the user\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic); // Initialize the wallet\n    console.log(\"Wallet initialized!\");\n\n    // fetch networks from backend\n    let networks = await sdk.getNetworks();\n    // set the network configuration for the wallet\n    sdk.setNetwork(networks[0].key);\n\n    let transactions = await sdk.getWalletTransactionList(pin, 0, 10);  // Get the transaction list\n    console.log(\"Wallet transactions list: \" + JSON.stringify(transactions));\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#22-initialize-wallet-from-shares","title":"22. Initialize Wallet from Shares","text":"Rust <pre><code>use etopay_sdk::{ErrorKind, WalletError};\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\nmod utils;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    dotenvy::dotenv().ok();\n\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Fetch networks from backend\n    let networks = sdk.get_networks().await.unwrap();\n    let iota_network_key = &amp;networks.first().unwrap().key;\n    sdk.set_network(iota_network_key.to_string()).await.unwrap();\n\n    // use wallet without creating a new one first\n    let output = sdk.generate_new_address(&amp;user.pin).await;\n\n    match output {\n        Ok(_address) =&gt; {\n            println!(\"Wallet initialized successfully\");\n        }\n\n        Err(etopay_sdk::Error::Wallet(WalletError::WalletNotInitialized(ErrorKind::MissingPassword))) =&gt; {\n            // Wallet requires a password, try again with the password provided\n            sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n\n            let result = sdk.generate_new_address(&amp;user.pin).await;\n            if result.is_ok() {\n                println!(\"Wallet initialized successfully with password set\");\n            } else {\n                panic!(\"Unexpected result after providing password: {:?}\", result);\n            }\n        }\n\n        Err(etopay_sdk::Error::Wallet(WalletError::WalletNotInitialized(ErrorKind::SetRecoveryShare))) =&gt; {\n            // Ask user for recovery share\n            let share = \"&lt;User Input&gt;\".parse().unwrap();\n\n            sdk.set_recovery_share(share).await.unwrap();\n\n            let result = sdk.generate_new_address(&amp;user.pin).await;\n            if result.is_ok() {\n                println!(\"Wallet initialized successfully with recovery share\");\n            } else {\n                panic!(\"Unexpected result after setting recovery share: {:?}\", result);\n            }\n        }\n\n        Err(etopay_sdk::Error::Wallet(WalletError::WalletNotInitialized(ErrorKind::UseMnemonic))) =&gt; {\n            sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n            sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n                .await\n                .unwrap();\n\n            let result = sdk.generate_new_address(&amp;user.pin).await;\n            if result.is_ok() {\n                println!(\"Wallet initialized successfully from mnemonic\");\n            } else {\n                panic!(\"Unexpected result after creating wallet from mnemonic: {:?}\", result);\n            }\n        }\n        other =&gt; panic!(\"unexpected result: {other:?}\"),\n    }\n\n    // Ensure the wallet is functioning\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"New address : {address} , Wallet balance: , {balance:?}\");\n}\n</code></pre>"},{"location":"SDK%20Modules/KYC%20Onboarding/","title":"KYC Onboarding","text":""},{"location":"SDK%20Modules/KYC%20Onboarding/#what-is-kyc","title":"What is KYC?","text":"<p>Know Your Customer (KYC) is a regulatory and compliance process used by financial institutions and businesses to verify the identity of their customers. The primary goal of KYC is to prevent fraudulent activities such as identity theft, financial fraud, and money laundering. Traditionally, KYC involves collecting personal information, such as government-issued identification, proof of address, and other relevant documents, to ensure that individuals engaging in financial transactions are legitimate.</p> <p>With the rise of blockchain and decentralized finance (DeFi), the importance of KYC has extended beyond traditional banking into the Web3 ecosystem. While the decentralized nature of Web3 promotes anonymity and self-sovereign identity, it also introduces challenges in regulatory compliance, particularly in preventing illicit financial activities.</p>"},{"location":"SDK%20Modules/KYC%20Onboarding/#the-purpose-of-kyc-in-web3","title":"The Purpose of KYC in Web3","text":"<p>In the Web3 industry, KYC serves several key purposes:</p> <ol> <li> <p>Preventing Money Laundering \u2013 Cryptocurrencies and blockchain-based financial systems can be exploited by criminals to launder illicit funds due to their pseudonymous nature. Implementing KYC ensures that users engaging in financial transactions are properly identified, reducing the risk of money laundering.</p> </li> <li> <p>Ensuring Regulatory Compliance \u2013 Governments and regulatory bodies worldwide have imposed Anti-Money Laundering (AML) and Counter-Terrorist Financing (CTF) laws that apply to cryptocurrency exchanges, DeFi platforms, and NFT marketplaces. KYC compliance helps Web3 projects adhere to these regulations and avoid legal repercussions.</p> </li> <li> <p>Mitigating Fraud and Scams \u2013 The Web3 space has seen numerous scams, including rug pulls, Ponzi schemes, and fraudulent token offerings. By implementing KYC, projects can verify the legitimacy of users and project teams, fostering trust within the ecosystem.</p> </li> <li> <p>Protecting Institutional Investors \u2013 Institutional investors are increasingly exploring Web3 and DeFi. However, without proper KYC measures, they face significant risks. KYC-compliant platforms provide greater security and legitimacy, encouraging broader institutional participation.</p> </li> </ol>"},{"location":"SDK%20Modules/KYC%20Onboarding/#onboarding-users-for-kyc","title":"Onboarding users for KYC","text":"<p>Currently, the ETOPay SDK offers two alternatives for onboarding users through a KYC process. These two processes are indepedent of each other, however the ETOPay SDK consults the backend to check which process the user has started and also continues from the state where the user previously left. Hence, in case if the user loses their devices, or re-initiates the onboarding through another client of the ETOPay SDK, the user is guided onward from where they left of, instead of starting from the beginning.</p> <p>The two KYC processes that are offered by the SDK are:</p> <ol> <li>Using Postident as the KYC Provider</li> <li>Using ETOSPHERES Exchange (previously known as viviswap) as the KYC Provider.</li> </ol> <p>The onboarding steps in the SDK follow a very simple flow:</p> <ol> <li>Check if the user is already KYC verified. This is independent of the process the user followed.</li> <li>If the user is not verified, check if the user has already started a process.</li> <li>If the user as already started a process, continue the process with the same provider as the user has started.</li> <li>Or offer the user a choice and start with the chosen provider.</li> </ol> Info <p>Currently, the federation of the KYC status of the user across multiple customers is not supported. This would mean that the same user might need to perform a KYC again for a different ETOPay customer. This feature is highly demanded as it improves the user onboarding, and it provides new ETOPay customers immediate access to a verified user pool. However, the feature is currently under scrutiny and is bound to be planned in future releases of the ETOPay platform.</p> <p>Warning</p> <p>There is a provider lock, that currently prevents users from switching between the two providers, or in future, potentially multiple providers, once they chose to start the process with a certain provider. Due to this, the user is forced to complete the onboarding with the same provider they chose at the beginning and have no option of switching providers once a process is started.</p>"},{"location":"SDK%20Modules/KYC%20Onboarding/#onboarding-users-via-postident","title":"Onboarding users via Postident","text":"<p>Onboarding users via Postident allows users with existing wallets to simply perform a KYC onboarding, migrate their existing mnemonic to ETOPay and start using the wallet services directly.</p> <p>Before being able to use the Postident integration in the SDK for all the end-users, the customers should register with Postident and get a business account for using their services. The SDK is merely a wrapper around the Postident Standard Connect and Response (SCR) interface for faster onboarding without the need of programming own integrations. After creating a business account, the Postident provides information as shown in the table below.</p> <p>There are typically two access credentials provided. One access to their <code>TestApp</code> on the ITU can be plugged in to the ETOPay test environment. The other access to their production can be plugged in to the ETOPay live environment.</p> Info <p>Postident also publishes their own SDK for both Android and iOS platforms. These SDK's work in conjunction with the ETOPay SDK. The SDK's from Postident provide the UI/UX for the KYC Onboarding, whilst the ETOPay SDK handles the business logic of generating case Ids, tracking them and securely encrypting. Simply feeding the case Ids generated by the ETOPay SDK to the Postident SDK provides a complete all rounded KYC Integration for end-users with a simplified UI/UX</p> <p>For any additional help regarding onboarding with Postident as a business customer or questions for integration with Postident, please free to always reach out to our team</p> <p>Warning</p> <p>The JSON Web Encryption(JWE) is always enabled on all endpoints at ETOPay. Hence, after on-boarding with Postident, creating cases intially might fail, if you have not reached out to Postident and informed them to also enable the encryption on their end. This included also enabling encryption for ITU (Test environment of ETOPay). This is default behavior and for security reasons, the JWE will never be disabled, even on ETOPay test environment.</p> <p>The following table shows the information that is required by the custoemr. By plugging it in the ETOPay application dashboard, it permits ETOPay to connect to the Postident services and enable the KYC onboarding for all SDK clients.</p> Parameter Description ClientId This information is used in the ETOPay application for connecting to the Postident SCR. This basically represents the username for login using basic auth for all Postident SCR endpoints. Login password This information authenticates the above client against all the SCR endpoint and is passed in the header along with the username as basic authentication Data password/Encryption password This password is used for generating the HMAC of the public key, which is generated and used by the system for JWE payloads. <p>More information on Postident can be found in their handbook</p>"},{"location":"SDK%20Modules/KYC%20Onboarding/#onboarding-users-via-etospheres-exchange","title":"Onboarding users via ETOSPHERES Exchange","text":"<p>Similar to Postident, in order to use the ETOSPHERES Exchange as a process for KYC on-boarding of users, customers are required to register their business account directly with the ETOSPHERES Exchange. Once registered, the customers are able to access credentials listed below in the table, one each for a test and for a live environment.</p> Parameter Description Organisation Id This information identifies the organisation account at the Exchange. API Key This key is used as part of the JWT payload. This key is unique for each organisation and environment API Secret This secret is used for generating the HMAC-based signature of the JWT Payload. This secret is also unique to each organisation and environment <p>For more information on how ETOPay authenticates against the API of the Exchange, please see here</p> <p>Please reach out to us directly for onboarding as a business on the ETOSPHERES Exchange here</p> <p>The onboarding of users and their related KYC process is described directly in our documentation hosted at the exchange. The ETOPay SDK completely integrates the organisations API scope. In addition, the existed users on the exchange are also immediately federated to the organisations, once they approve to share their KYC data with the customer attached organisation at the exchange. This feature is however, not yet available directly in ETOPay and the approval for sharing data is only possible right now via an E-Mail from the user.</p>"},{"location":"SDK%20Modules/KYC%20Onboarding/#order-of-verification","title":"Order of verification","text":"<p>The order of verification in the SDK strictly follows the order of verification as recommended by the Exchange API.</p> <p>general \u2013 Provide general information such as country of origin or current country of residence. personal \u2013 Provide further information about yourself and your current occupation. residence \u2013 State your place of residence and confirm it. identity \u2013 Verify your identity with the help of legal documents. amla \u2013 Answer a few questions about your income and assets. documents \u2013 Upload other missing documents.</p>"},{"location":"SDK%20Modules/KYC%20Onboarding/#risk-levels","title":"Risk levels","text":"<p>In order to query only the most relevant data in accordance with our customers' requirements and to comply with regulatory conditions, we maintain a risk level for each customer. This is a unsigned integer and can assume values from 1 to 99. The higher this value, the more risky the business relationship is assessed to be and the more limited we provide our functionalities. This mechanism helps us to comply with regulatory requirements.</p> <p>For values greater than or equal to 70, by default, the customer does not have permission to transact business through our services. At a lower value, the customer has an increasingly higher volume available per month with descending risk level.</p> Risk level Trading enabled KYC steps required Daily limit Monthly limit Comments 90 NO n/a 0 EUR 0 EUR 80 NO n/a 0 EUR 0 EUR 70 NO n/a 0 EUR 0 EUR default risk level of a new registered user 60 YES general &amp; personal 699 EUR 20.000 EUR 55 YES general &amp; personal 699 EUR 20.000 EUR in addition this user has added at least one verified bank account on it's name 50 YES general, personal, identity, residence, amla &amp; documents 699 EUR 20.000 EUR there\u2019s a criteria with increased risk for this user 40 YES general, personal, identity, residence, amla &amp; documents 14.999 EUR 250.000 EUR no specific risk criteria 30 YES general, personal, identity, residence, amla &amp; documents 250.000 EUR 250.000 EUR full verification plus source of funds document 20 YES general, personal, identity, residence, amla &amp; documents individual individual 10 YES general, personal, identity, residence, amla &amp; documents individual individual <p>Users can further lower their risk level by providing more information about themselves. For example, to set the risk level to 60 the exchange needs information about the country of origin and the person (general and personal kyc step). To achieve a risk level of 40, all KYC steps (general, personal, identity, residence, amla &amp; documents) must be completed. To achieve an even lower risk level, the exchange requires further individual information from the user. To do this, the user can directly contact support.</p>"},{"location":"SDK%20Modules/Managing%20user/","title":"User management","text":"<p>The SDK is designed to allow multiple users working with their own wallets on the same end devices sharing the same storage space. This makes it easy for a single person to have multiple alias users for different purposes and use different wallets for each of them to have a clear separation of risks.</p> <p>The user initialization is done by two main operations in the SDK.</p> <p>Creating a new user : This creates a new user in the in-memory database. All the properties of the user, like his selected KYC process, his KYC status, his access token for the backend, pin, encrypted password, etc... are set with the default values. A salt is generated for the user, which will be used later for encrypting the password.</p> <p>Initializing a user : This function initializes the user for a new session. It also checks that a valid access token has been provided by updating the KYC status of the user from the backend in the SDK internal state.</p>"},{"location":"SDK%20Modules/Managing%20user/#creating-a-new-user","title":"Creating a new user","text":"<p>User creation in the SDK is compulsory. This user is only a local user which might be already existing in the identity management provider.  </p> Note <p>The user might already exist in the OAuth system, as well as every where else, including ETOPay backend. However, the SDK associates the local user to the system user only when an access token is provided.</p> <p>The SDK supports multi-user environments and switching between users is fairly simple. Creating a user in the SDK informs the SDK about the user and allows the SDK to manage the user's state locally, whilst syncing it with the backend periodically.</p> <p>This allows the SDK to be used across multiple devices, and ideally on the same device, on multiple storage path prefixes. This means, that changing the storage path prefix would result in the SDK unknowing the existence of the user and would require to create the user once again.</p> <p>Creating a new user can be done using the <code>create_new_user</code> function which takes the <code>username</code> input parameter. Before creating a user, it is important that at least the storage path is set in the SDK.</p> <p>The <code>username</code> should always match the <code>preferred_username</code> claim on the JWT <code>access_token</code>, otherwise the SDK would not be able to access the backend services for that user. Through this, the newly created SDK local user gets recognized in the system as a valid user.</p> Tip <p>The application can extract the <code>preferred_username</code> information automatically from the JWT claim and set the username directly, instead of asking the user to enter the input. A user might mistype or misunderstand and enter a username which might later not work. This would lead to a bad end-user experience and should be avoided.</p> <p>Note</p> <p>The code snippets provided are intended as pseudo-code to demonstrate logic and workflows. They are not guaranteed to compile, execute, or function as-is. Users should adapt and validate them according to their specific requirements and development environment.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    sdk.create_new_user(\"username\").await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.createNewUser(\"username\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport ETOPaySdk\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.createNewUser(username: \"username\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.createNewUser(\"username\");\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#initializing-a-user-and-access-token-refresh","title":"Initializing a user and access token refresh","text":"<p>The user is created and needs to be initialized before any state updates or wallet-related operations can be performed for this user. This allows the SDK to create multiple users and by using the initializing function, only the selected user is activated for the session. Without initializing a user, all operations related to the user would fail or conversely the previously initialized user's session will be used and might corrupt the state! To protect this from happening, before initializing the user, a corresponding access token is required. An invalid access token would result in failure of the initialization.</p> <p>The access token brings the following safe operations for the SDK:</p> <ol> <li>Only the correct user with the username would be initialized. Mismatch would cause an error.</li> <li>The application can only initialize a user, only after the authorization of the actual person, since they would need to share their credentials for creating an access token.</li> <li>Any user whose rights have been revoked, due to misuse reports, would not be able to use the system as the access token would be invalid and generating a new one would not also work.</li> </ol> <p>Warning</p> <p>The user management is local to the end devices and deleting the application data, cache, temporary data files, etc... or changing the storage path prefix in the configuration would result in a loss of state and that would require the application to re-create and re-initialize user.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    sdk.create_new_user(\"username\").await.unwrap();\n\n    sdk.refresh_access_token(\"access_token\").await.unwrap();\n    sdk.init_user(\"username\").await.unwrap();\n\n    // other SDK functions now use the initialized user\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.createNewUser(\"username\");\n            sdk.refreshAccessToken(\"accessToken\");\n            sdk.initializeUser(\"username\");\n            // other SDK functions now use the initialized user\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport ETOPaySdk\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.createNewUser(username: \"username\")\n    try await sdk.refreshAccessToken(access_token: \"access_token\")\n    try await sdk.initUser(username: \"username\")\n    // other SDK functions now use the initialized user\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.createNewUser(\"username\");\nawait sdk.refreshAccessToken(\"access_token\");\nawait sdk.initializeUser(\"username\");\n// other SDK functions now use the initialized user\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#deleting-a-user","title":"Deleting a user","text":"<p>Deleting the user is simply deleting the user entity from the local database, while maintaining entries for other users. The delete user also calls the backend API to trigger an archiving action for the user. Deleting the user also deletes all the local data files for the user, which in this case are files related to the wallet. Since, this is a one-way operation a user is required to enter the pin, that they have set for the wallet. If there is no wallet setup, the pin can be skipped and the user is simply deleted locally and archived in the backend.</p> <p>Danger</p> <p>Deleting a user not only deletes the user in the system but also deletes all local files and information from the device. This means, that the wallet is also deleted. Hence, a pin is used to verify if the user wishes to delete all this information. Deletion of a wallet without having a backup file or without the mnemonic is extremely dangerous as it can potentially lead to permanent loss of funds.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    sdk.create_new_user(\"username\").await.unwrap();\n    sdk.refresh_access_token(\"access_token\").await.unwrap();\n    sdk.init_user(\"username\").await.unwrap();\n\n    let pin = \"1234\"; \n    // only if wallet was created by the user, a pin value is required.\n    // otherwise, it is None.\n    sdk.delete_user(Some(pin)).await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.etopay.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.createNewUser(\"username\");\n\n            sdk.refreshAccessToken(\"accessToken\");\n            sdk.initializeUser(\"username\");\n\n            String pin = \"1234\"; \n            // only if wallet was created by the user, a pin value is required.\n            // otherwise, it is null.\n            sdk.deleteUser(pin)\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport ETOPaySdk\n\nlet sdk = ETOPaySdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.createNewUser(username: \"username\")\n\n    try await sdk.refreshAccessToken(access_token: \"access_token\")\n    try await sdk.initUser(username: \"username\")\n\n    let pin = \"1234\"; \n    // only if wallet was created by the user, a pin value is required.\n    // otherwise, it is nil.\n    try await sdk.deleteUser(pin: pin)\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/etopay_sdk_wasm\";\n\nconst sdk = await new ETOPaySdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.createNewUser(\"username\");\nawait sdk.refreshAccessToken(\"access_token\");\nawait sdk.initializeUser(\"username\");\n\nlet pin = \"1234\"; \n// only if wallet was created by the user, a pin value is required.\n// otherwise, it is null.\nawait sdk.deleteUser(pin);\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#user-lifecycle-overview","title":"User lifecycle overview","text":"<pre><code>      Username    Refresh access   Username              Pin              \n         |            token          |                      |             \n         |             |             |                      |             \n         |             |             |                      |             \n         |             |             |                      |             \n    +----v---------+   |     +-------v------+        +------v---------+   \n    |              |   |     |              |        |                |   \n    |  Create      |   |     | Initialize   |        |     Delete     |   \n    |  new         +---v-----&gt; User         +--------&gt;     User       |   \n    |  User        |         |              |        |                |   \n    +--------------+         +-----+--------+        +----------------+   \nOnce                                |\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nMultiple                            |\nTimes                   +-----------v-----------------+\n                        |  User           Wallet      |\n                        |  State          Operations  |\n                        |  Change                     |\n                        +-----------------------------+\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/","title":"Wallet management","text":"<p>The SDK provides users with the opportunity to host their own wallets on their personal end-devices in a safe and easy manner. Before discussing wallet management, some information on wallets and what they are is needed to understand how to manage non-custodial hot wallets.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#hot-wallets-the-swift-side-of-crypto","title":"Hot Wallets: The Swift Side of Crypto","text":"<p>Picture a hot wallet as the bustling city centre of your digital finances. Hot wallets are online, connected to the internet, and readily available for transactions. They provide users with quick access to their cryptocurrencies, making them ideal for active trading and daily transactions. Think of them as your go-to pocket wallet for everyday spending in the digital realm.</p> <p>However, convenience comes at a cost. The very connectivity that makes hot wallets user-friendly also renders them more vulnerable to cyber threats. Hacking attempts and online attacks pose a constant risk, making it crucial for users to exercise caution and implement additional security measures when relying on hot wallets.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#wallet-storage","title":"Wallet Storage","text":"<p>The wallet internally uses a Shamir's Secret Sharing (SSS) algorithm to securely store and retrieve the mnemonic of the user's wallet. The mnemonic entropy (as defined in BIP-0039 using the english wordlist) used to derive the private key is split into three shares, of which two are needed to recover the actual mnemonic. The shares are then stored in three different places (in order of priority):</p> <ol> <li>Local Share: Stored on the device in a file, or in the browser local storage if on the web. It never leaves the device.</li> <li>Recovery Share: Stored in the OAuth provider, currently in Keycloak, and accessed through the ETOPay backend. Also stored in-memory and accessible in the SDK for use in a situation where the wallet is used offline.</li> <li>Backup Share: Stored in the ETOPay backend. Encrypted with the user's chosen password (see below for more information about the password).</li> </ol> <p>This setup brings the following benefits:</p> <ul> <li>The ETOPay backend can never recover the mnemonic since one of the two accessible shares is encrypted with the user's password.</li> <li>If access to the ETOPay backend is lost, the user can still recover their wallet using the Local and Recovery shares, provided that they have had the opportunity to store the latter when setting up their wallet.</li> <li>Similarly, in the case where the wallet is used offline, the Local and Recovery shares are all that is needed to reconstruct the wallet mnemmonic.</li> </ul> <p>Before any wallet interaction can be performed, the shares need to be collected and, if necessary, decrypted. Therefore, the user has to provide their <code>pin</code> for all wallet operations. If the wallet is operating offline, the Recovery Share also need to be set manually (see <code>get_recovery_share</code> and <code>set_recovery_share</code>). If a share, password or pin is missing when trying to combine the shares and interact with the wallet, an error is returned. See Example 22. Initialize Wallet from Shares for more information on how to handle those errors correctly. After recombining the shares, the Local Share and the in-memory Recovery Share are automatically recreated. Thus the next time the mnemonic is recreated, two shares are already present locally and no request to the backend is needed.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#networks","title":"Networks","text":"<p>The wallet uses the concept of Networks to select which blockchain to interact with. The ETOPay SDK currently supports interacting with the following protocols:</p> <ul> <li>Stardust</li> <li>Ethereum Virtual Machine (EVM)</li> <li>ERC-20 Smart Contracts running on EVM.</li> <li>Upcoming: IOTA Rebased using Move.</li> </ul> <p>Before any interaction with the wallet and a network can be done, a network need to be selected. This is done using the <code>set_network</code> method, which takes the network's unique <code>key</code> as a parameter. The list of networks can be fetched from the backend using <code>get_networks</code> to for example allow the end user to select which network they want to interact with.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#transaction-storage","title":"Transaction Storage","text":"<p>Due to the nature of blockains, and to avoid having to scan all the historical blocks, the SDK needs to locally keep track of all the transactions a user has performed. Therefore the wallet has a local database, which also stores all user information, that holds this information. This database is stored in a file on compatible platforms and in the browser local storage if used on the web. To configure the location of this database, please see Configuring the SDK.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#wallet-lifecycle","title":"Wallet Lifecycle","text":""},{"location":"SDK%20Modules/Managing%20wallet/#pin-and-password","title":"Pin and Password","text":"<p>To securely store the mnemonic one of the shares is encrypted. This could cause usability issues if the user is required to provide this password, which generally need to meet certain standards of length and complexity, for every interaction with the wallet. Thus the SDK is designed to use both a <code>password</code> and a <code>pin</code>. Before any wallet operations can be performed (eg. creating a new wallet or calling a function on an existing wallet) the user needs to set this password (see <code>set_wallet_password</code> and <code>is_wallet_password_set</code>), which is used to encrypt the shares, together with a pin. The password is encrypted using the pin and stored locally in the users profile.</p> <p>With this setup, every operation with the wallet where a password is needed to recombine the shares only requires the user to enter and remember the pin. This solves the problem of user experience, which can be further improved by using the secure storage available on some platforms such as biometric or facial recognition authentication for storing the pin.</p> <p>Furthermore there are a few methods for working with the password and pin combination:</p> <ul> <li>Use <code>change_pin</code> to change the pin of the password.</li> <li>Use <code>verify_pin</code> to verify correctnes of the pin.</li> <li>Use <code>set_wallet_password</code> to set the initial password and to change the password (in which case this will recreate and re-encrypt the shares if they already exist).</li> <li>Use <code>is_wallet_password_set</code> to check if the password has already been set.</li> </ul> <p>See the examples for more details:</p> <ul> <li>Example 10. Verify Pin</li> <li>Example 11. Reset Pin</li> <li>Example 12. Change Password</li> </ul>"},{"location":"SDK%20Modules/Managing%20wallet/#creating-a-wallet","title":"Creating a wallet","text":"<p>To create a new wallet (if no existing shares exist, for example). The user first needs to set a password and pin combination (see <code>set-wallet-password</code>). A new wallet can then be created in multiple ways, which all generate and uploads the shares and thus requires the pin to be provided:</p> <ol> <li>Create a new random wallet (<code>create_wallet_from_new_mnemonic</code>). This generates a random mnemonic that is then returned to the user for backup purposes.</li> <li>Create a wallet from an existing mnemonic (<code>create_wallet_from_existing_mnemonic</code>). This takes a user-provided mnemonic and creates a wallet. See Example 4. Migrate Wallet From Mnemonic.</li> <li>Create a wallet from a backup (<code>create_wallet_from_backup</code>). This takes the bytes of the backup file and the backup password and creates a wallet. A backup can be created with <code>create_wallet_backup</code>. See Example 5. Migrate Wallet From Backup.</li> </ol> Warning <p>In case a wallet is created from a new random mnemonic, make sure that the end user has the opportunity to make a copy of it. You can let the user re-enter the mnemonic and validate it with <code>verify_mnemonic</code> before allowing the user to continue using the wallet.</p> Warning <p>Creating a new wallet will overwrite the old one (if there was any). This could cause loss of funds if not done carefully.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#creating-and-restoring-wallet-backups","title":"Creating and restoring wallet backups","text":"<p>The SDK provides functionality to create a backup file in <code>kdbx</code> format as a byte array. Backups can only be created if a wallet exists.</p> <p>Create a backup using <code>create_wallet_backup</code> and provide the following:</p> <ul> <li><code>pin</code>: This is the same PIN that was set for the wallet. Needed to combine the shares into the mnemonic to backup.</li> <li><code>backup_password</code>: A new, separate password set specifically for securing the backup file. This is not the same password as the one used for the wallet.</li> </ul> <p>This call returns an array of bytes which, for example, can we written to a user-provided file path or offered as a download.</p> <p>To restore the backup, use <code>create_wallet_from_backup</code> and provide:</p> <ul> <li>The bytes returned from the call to create a backup.</li> <li><code>pin</code>: the pin set for the currently set password. Used to decrypt the password used to encrypt the shares.</li> <li><code>backup_password</code>: the password provided used during the backup process.</li> </ul> <p>This will create shares for the new wallet.</p> <p>See Example 5. Migrate Wallet From Backup for a complete example of creating and restoring from a backup.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#deleting-the-wallet","title":"Deleting the wallet","text":"<p>The wallet can be deleted using <code>delete_wallet</code>. This is a one-way operation to be used under extreme caution as it could result in permanent loss of funds. Note that, similar to any other wallet operation, deleting the wallet is also a wallet operation and requires the user to enter their pin.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#using-wallet-functions","title":"Using Wallet functions","text":"<p>After a wallet is created, or if the user has already created a wallet before, it can be used by calling any of the relevant methods. See for example:</p> <ul> <li><code>generate_new_address</code></li> <li><code>get_balance</code></li> <li><code>send_amount</code></li> </ul>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/","title":"Transactions, Swaps and Purchases","text":"<p>The SDK is primarily used to perform transactions. The type of transactions that the SDK currently facilitates are</p> <ol> <li>Wallet transactions</li> <li>Swap transactions</li> <li>Purchase transactions</li> </ol>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#wallet-transactions-flow","title":"Wallet transactions flow","text":"<pre><code>+---------------+                      +---------------+\n|               |                      |               |\n|               |                      | Wallet        |\n| Wallet        +----------------------&gt; Address       |\n| Address       |                      | Receiver      |\n| Sender        |                      |               |\n+---------------+                      +---------------+\n</code></pre> <p>The wallet transaction is a simple transfer of funds from one address to another facilitated by the DLT network node and the wallet software running within the SDK.</p>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#swap-transactions-flow","title":"Swap transactions flow","text":"<p>A swap is simply an exchange of value from one currency to another. In the current scenario, the swap is always between SMR &lt;--&gt; EURO currencies. This is executed at viviswap exchange.</p> <p>For payments in EURO, only the SEPA transfer method is currently supported. See the german explanation here and the english explanation here</p> <p>The EURO payment needs the user to setup and add their IBAN (International Bank Account Number) to the viviswap exchange. Through this, the viviswap uses SEPA transfers to this IBAN, whenever a swap is triggered from SMR to EURO. The other way around, currently, since direct debit is not setup from the bank of viviswap, the user has to transfer manually from exactly this IBAN (viviswap verifies it in every transfer) to the IBAN owned by viviswap with the amount and a reference number provided by viviswap.</p> <ol> <li><code>get_iban_for_viviswap</code>: This function allows the user query their own IBAN saved at viviswap.</li> <li><code>ensure_detail</code>: This function verifies if a detail created at viviswap is legitimate, syntactically and semantically. A detail is basically an address for a particular payment method. The various payment methods used by viviswap are SMR, IOTA, BTC, ETH, etc... for crypto-currencies and PAYPAL, SEPA, etc... for EURO payments. For example, the address for the payment method SMR would be shimmer wallet address and the address for the payment method SEPA would be the IBAN.</li> <li><code>update_iban_for_viviswap</code>: This function updates the IBAN of the user in the viviswap exchange. The update is actually an advanced <code>upsert</code> action. The update would insert the IBAN if none exists and also replace the existing IBAN with the new one.</li> <li><code>create_deposit_with_viviswap</code>: This function creates details of a fiat to crypto swap. Deposit is to be understood as deposit of funds to a crypto currency address. Currently, the swap is between EURO to SMR. Since, there is no direct debit authorization available, creating the deposit generally means getting information about the bank details of viviswap and the reference number, and advising the user to make a SEPA transfer in the required amount.</li> <li><code>create_detail_for_viviswap</code>: This function creates a user detail for a payment method. This could be adding the crypto address for a certain payment method to the viviswap exchange. This detail with its id can then be directly used for the swaps.</li> <li><code>get_payment_method_id_viviswap</code>: This is a generic function and has to be called once to cache the UUIDs of all the payment methods supported by viviswap.</li> <li><code>create_withdrawal_with_viviswap</code>: This function is the opposite of deposit. Withdrawal is to be understood as withdrawal of funds from a crypto currency address. If a pin is provided, the function automatically immediately transfers money from the crypto address of the user to that of viviswap and ideally viviswap would automatically transfer the funds to the IBAN created in their system. If no pin is provided, the user is shown the crypto address of the chosen payment method and the user can decide to transfer the funds to this address at any point.</li> <li><code>get_swap_list</code>: This function gives the list of swaps performed at viviswap.</li> <li><code>get_swap_details</code>: This function gives details about a swap, like information on fees, exchange rate, the swap status, etc...</li> <li><code>get_exchange_rate</code>: This function provides the exchange rate for the involved currencies in the swap. Currently, the exchange rate is always provided with EURO as base currency, i.e. it is either SMR/EURO or IOTA/EUR or BTC/EURO and so on... An inversion of the exchange rate gives the reverse rate and should be calculated by simply inverting the value. As confirmed by viviswap, there are no vertical spreads to be considered here!</li> </ol> <pre><code>                              Deposit Flow                        \n\n\n            +------------+            |          +------------+   \n            |            |            |          |            |   \n            | User       |            |          | Viviswap   |   \n            | Wallet     &lt;------------+----------+ Wallet     |   \n            | Address    |            |          | Address    |   \n            |            |            |          |            |   \n            +------------+            |          +------^-----+   \n                                      |                 |         \n                                      |                 |         \n                                      |                 |         \n                                      |                 |Trigger  \n                                      |                 |         \n                                      |                 |         \n                                      |                 |         \n            +------------+            |            +----+-------+ \n            |            |            |            |            | \nUser        | User       |     Bank   |            |  Viviswap  | \n------------&gt; IBAN       +------------+------------&gt;  IBAN      | \nAction      |            |     Ref.   |            |            | \n            |            |     Nr.    |            |            | \n            +------^-----+            |            +------------+ \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |             +------------+\n                   +------------------+-------------+            |\n                                      |             |  Create    |\n           Update  -------------------+-------------&gt;  Deposit   |\n           User           Payment     |             |  Detail    |\n           IBAN           Detail      |             |            |\n                                      |             +------------+\n                                      |                           \n                                      |                           \n                              User    |    Viviswap               \n</code></pre> <pre><code>                 Withdraw Flow                       \n\n                                   +------------+    \n                                   |            |    \n  User                    |        |  Create    |    \n  ------------------------+--------&gt;  Withdraw  |    \n  Action                  |        |  Detail    |    \n              Viviswap    |        |            |    \n      +-------------------+--------+------------+    \n      |       Address     |                          \n      |                   |                          \n+-----v------+            |          +------------+  \n|            |            |          |            |  \n| User       |            |          | Viviswap   |  \n| Wallet     +------------+----------&gt; Wallet     |  \n| Address    |            |          | Address    |  \n|            |            |          |            |  \n+------------+            |          +------+-----+  \n                          |                 |        \n                          |                 |        \n                          |                 |        \n                          |                 |Trigger \n                          |                 |        \n                          |                 |        \n                          |                 |        \n+------------+            |            +----v-------+\n|            |            |            |            |\n| User       |            |            |  Viviswap  |\n| IBAN       &lt;------------+------------+  IBAN      |\n|            |            |            |            |\n|            |            |            |            |\n+------------+            |            +------------+\n                          |                          \n                          |                          \n                          |                          \n                  User    |    Viviswap              \n</code></pre>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#purchase-transactions-flow","title":"Purchase transactions flow","text":"<p>The purchase transaction is a process different than a swap or a wallet transaction. The purchase is a process of exchanging funds for an underlying artefact. An artefact can be something promised between two parties like a photo, video, or a compliment on a photo, sensor data, services, licenses, etc... The SDK is only interested in creation, querying and confirmation of these purchase requests. The rest of the business logic flow is handled by the corresponding service in ETOPay infrastructure. The transfer of artefact can happen only after a successful execution of the purchase request. This information can be verified at all times by querying the status of the purchase request and the details of the purchase request.</p> <p>A purchase request can be created at any time and is unique per purchase. A purchase id is returned by the infrastructure to track this particular request. Currently, polling is used to wait for the purchase request to be valid. It can be invalid for multiple reasons, as defined in the infrastructure. In case the request turns out to be valid, then the details (supplemented by the infrastructure) are fetched and a confirmation is done through the sdk.</p> <p>The confirmation of a purchase request means that funds are required to be released from the wallet and this operation needs the pin from the user, to avoid creation and confirmation of purchase request which might not have been authorized by the user. The confirmation triggers a wallet transaction to the recipient's wallet address as well as to the system's wallet address. The purchase details deliver this information for each individual purchase request. The result of the wallet transaction is then added to the purchase request and sent to the infrastructure as part of the confirmation body, so that the infrastructure can search for the transaction on the DLT network.</p> <pre><code>                                        |                      \n                                        |                      \n                                        |                      \n                 +-------------+        |                      \n                 |             |        |                      \n       User      | Create      |        |                      \n     +-----------&gt; Purchase    +--------+-+     +-------------+\n     | Request   | Request     |        | |     |             |\n     |           |             |        | |     |  (Polling)  |\n     |           +-------------+        | +-----&gt;  Get        |\n     |                                  |       |  Purchase   |\n     |                                  |       |  Status     |\n     |                                  |       +------+------+\n     |      Pin                         |              |       \n     +-------------------+              |              |Valid  \n                         |              |              |       \n                         |              |       +------v------+\n                  +------v------+       |       |             |\n                  |             |       |       |  Get        |\n    Wallet        | Confirm     &lt;-------+-------+  Purchase   |\n&lt;-----------------+ Purchase    |       |       |  Details    |\n    Transaction   | Request     |       |       |             |\n                  |             |       |       +-------------+\n                  +-------------+       |                      \n                                        |                      \n                                        |                      \n                                        |                      \n                                        |                      \n                               Once     |   Multiple times     \n                                        |                      \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/","title":"API Reference","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#levels-and-repeats","title":"Levels and Repeats","text":"Category Description Levels Basic The functions at these levels are absolutely necessary to use the SDK. Without calling these functions, the SDK is never in a correct state. Optional functions can be skipped, since they will take default values, if that is the requirement. Usage The functions at these levels can only be called once all basic level functions have successfully executed. Repeats Handle The functions need to be called every time a new SDK Handle (object) needs to be created via a constructor or after garbage collection of any existing old handles. User The functions need to be called every time a new SDK user needs to be created. Application The functions can be called any time while using the SDK, however they may fail, if the certain dependencies are not fulfilled."},{"location":"SDK%20Reference/SDK%20API%20Reference/#usage-infos-and-warnings","title":"Usage infos and warnings","text":"<p>Warning</p> <ul> <li>Viviswap and Postident KYC onboarding will not work if the user is already kyc verified.</li> <li>KYC onboarding with another provider will not work if the user is already started kyc onboarding with one of the other providers.</li> <li>Restoring a wallet backup may fail, if the wallet is already existing.</li> <li>Initializing User and initializing wallet may fail, if the user and wallet are already initialized. Since, there is no de-init function, the  SDK handle needs to be closed, or a new handle needs to be created to re init.</li> <li>Multiple handles to the wallet may also fail, since only atomic access are allowed.</li> <li>Deleting a user may fail if the backend cannot be reached.</li> </ul>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#javascript-typescript","title":"JavaScript / TypeScript","text":"<p>The API reference for the JS/TS bindings are available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#java","title":"Java","text":"<p>The Javadoc API reference for the Java bindings is available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#rust","title":"Rust","text":"<p>The Rustdoc API reference is available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#sdk-initialization-and-configuration","title":"SDK Initialization and Configuration","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#instantiating-the-sdk","title":"Instantiating the SDK","text":"Method Arguments Returns Dependencies Level Repeat Constructor Returns an <code>Error</code> if there is an issue in loading the dynamically or statically linked binary shared library, otherwise the handle to the SDK Basic Handle RustJavaTypescriptSwift <p>constructor</p> <p>constructor</p> <p>constructor</p> <p>Not available yet!</p> <pre><code>import ETOPaySdk\nlet sdk = ETOPaySdk()\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-configuration","title":"Set configuration","text":"Method Arguments Returns Dependencies Level Repeat Set the SDK configuration parameters. <code>config</code> - The JSON formatted string containing the configuration parameters. See SDK Configuration for more information of the available options. Constructor Basic Handle RustJavaTypescriptSwift <p>set_config</p> <p>setConfig</p> <p>setConfig</p> <p>Not available yet!</p> <pre><code>public func setConfig(config: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-supported-networks","title":"Get supported networks","text":"Method Arguments Returns Dependencies Level Repeat Get the supported networks. Returns a list of ApiNetwork. Constructor, Set Configuration, Refresh access token, User initialization Basic RustJavaTypescriptSwift <p>get_networks</p> <p>getNetworks</p> <p>getNetworks</p> <p>Not available yet!</p> <pre><code>public func getNetworks() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-network","title":"Set network","text":"Method Arguments Returns Dependencies Level Repeat Sets the network <code>network_key</code> - The key of the network as a string. Constructor Basic Handle RustJavaTypescriptSwift <p>set_network</p> <p>setNetwork</p> <p>setNetwork</p> <p>Not available yet!</p> <pre><code>public func setNetwork(network_key: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-build-information","title":"Get build information","text":"Method Arguments Returns Dependencies Level Repeat Get the SDK build information Returns a multi-line String containing: <code>Branch name</code> (e.g. main), <code>Commit hash</code> (e.g. 92cedead), <code>Build time</code> (e.g. 2024-10-29 12:10:09 +00:00), <code>Rust version</code> (e.g. 1.80.1 3f5fd8dd4 2024-08-06), <code>Toolchain channel</code> (e.g. stable-x86_64-unknown-linux-gnu) Usage Application RustJavaTypescriptSwift <p>get_build_info</p> <p>getBuildInfo</p> <p>getBuildInfo</p> <p>Not available yet!</p> <pre><code>public func getBuildInfo() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#user-functions","title":"User functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#creating-a-new-user","title":"Creating a new user","text":"Method Arguments Returns Dependencies Level Repeat Create a new user <code>username</code> - The username of the new user. Constructor, Set Configuration Basic User RustJavaTypescriptSwift <p>create_new_user</p> <p>createNewUser</p> <p>createNewUser</p> <p>Not available yet!</p> <pre><code>public func createNewUser(username: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#initializing-a-user","title":"Initializing a user","text":"Method Arguments Returns Dependencies Level Repeat Initialize a user <code>username</code> - The username of the user to initialize. Constructor, Set Configuration, Refresh access token, Create new user Usage Application RustJavaTypescriptSwift <p>init_user</p> <p>initializeUser</p> <p>initializeUser</p> <p>Not available yet!</p> <pre><code>public func initUser(username: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#refreshing-access-token","title":"Refreshing access token","text":"Method Arguments Returns Dependencies Level Repeat Refresh access token <code>access_token</code> - The new access token to be set. Constructor, Set Configuration Basic Application RustJavaTypescriptSwift <p>refresh_access_token</p> <p>refreshAccessToken</p> <p>refreshAccessToken</p> <p>Not available yet!</p> <pre><code>public func refreshAccessToken(access_token: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#checking-kyc-status","title":"Checking KYC status","text":"Method Arguments Returns Dependencies Level Repeat Check if the user's KYC status is verified <code>username</code> - The username of the user to check KYC status for. Returns <code>true</code> if the KYC status is verified, or <code>false</code> if it is not verified. User initialization Usage Application RustJavaTypescriptSwift <p>is_kyc_status_verified</p> <p>isKycVerified</p> <p>isKycVerified</p> <p>Not available yet!</p> <pre><code>public func isKycVerified(username: String) throws\n-&gt; Bool\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#delete-user","title":"Delete user","text":"Method Arguments Returns Dependencies Level Repeat Delete the currently active user and their wallet <code>pin</code> - The PIN of the user to be deleted. Required only if the user has created a wallet. User initialization Usage Application RustJavaTypescriptSwift <p>delete_user</p> <p>deleteUser</p> <p>deleteUser</p> <p>Not available yet!</p> <pre><code>public func deleteUser(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#wallet-functions","title":"Wallet functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet","title":"Create new wallet","text":"Method Arguments Returns Dependencies Level Repeat Creates a new wallet for the user with the specified PIN and password <code>pin</code> - The PIN for the wallet Returns the mnemonic phrase of the newly created wallet if successful. User initialization Usage User RustJavaTypescriptSwift <p>create_wallet_from_new_mnemonic</p> <p>createNewWallet</p> <p>createNewWallet</p> <p>Not available yet!</p> <pre><code>public func createNewWallet(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet-from-mnemonic","title":"Create new wallet from mnemonic","text":"Method Arguments Returns Dependencies Level Repeat Create a wallet from existing mnemonic <code>pin</code> - The PIN for the wallet, <code>mnemonic</code> - The mnemonic to migrate from User initialization Usage User RustJavaTypescriptSwift <p>create_wallet_from_existing_mnemonic</p> <p>createWalletFromMnemonic</p> <p>createWalletFromMnemonic</p> <p>Not available yet!</p> <pre><code>public func createWalletFromMnemonic(pin: String, mnemonic: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet-from-backup","title":"Create new wallet from backup","text":"Method Arguments Returns Dependencies Level Repeat Create a wallet from existing backup <code>pin</code> - The PIN for the wallet, <code>backup</code> - The bytes representing the backup file contents, <code>backup_password</code> - The password used when creating the backup User initialization Usage Application RustJavaTypescriptSwift <p>create_wallet_from_backup</p> <p>createWalletFromBackup</p> <p>createWalletFromBackup</p> <p>Not available yet!</p> <pre><code>public func restoreWalletFromBackup(pin: String, backup: RustVec&lt;UInt8&gt;, backup_password: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-a-wallet-backup","title":"Create a wallet backup","text":"Method Arguments Returns Dependencies Level Repeat Create a wallet backup <code>backup_password</code> - The password for the backup Returns the bytes of the created backup file if successful. User initialization Usage Application RustJavaTypescriptSwift <p>create_wallet_backup</p> <p>createWalletBackup</p> <p>createWalletBackup</p> <p>Not available yet!</p> <pre><code>public func createWalletBackup(backup_password: String) throws -&gt; RustVec&lt;UInt8&gt;\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#verify-mnemonic","title":"Verify mnemonic","text":"Method Arguments Returns Dependencies Level Repeat Verifies the mnemonic by checking if it matches the stored mnemonic <code>pin</code> - The PIN for the wallet, <code>mnemonic</code> - The mnemonic to verify Returns <code>true</code> or <code>false</code> whether the mnemonic is successfully verified. User initialization Usage User RustJavaTypescriptSwift <p>verify_mnemonic</p> <p>verifyMnemonic</p> <p>verifyMnemonic</p> <p>Not available yet!</p> <pre><code>public func verifyMnemonic(pin: String, mnemonic: String) throws -&gt; Bool\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#delete-wallet","title":"Delete wallet","text":"<p>Warning</p> <p>Deletes the currently active wallet, potentially resulting in loss of funds if the mnemonic or wallet is not backed up.</p> Method Arguments Returns Dependencies Level Repeat Delete the currently active wallet <code>pin</code> - The PIN for the wallet Wallet initialization Usage Application RustJavaTypescriptSwift <p>delete_wallet</p> <p>deleteWallet</p> <p>deleteWallet</p> <p>Not available yet!</p> <pre><code>public func deleteWallet(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#verify-pin","title":"Verify pin","text":"Method Arguments Returns Dependencies Level Repeat Verifies the pin for the wallet <code>pin</code> - The pin to verify Wallet initialization Usage Application RustJavaTypescriptSwift <p>verify_pin</p> <p>pinVerify</p> <p>verifyPin</p> <p>Not available yet!</p> <pre><code>public func verifyPin(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#reset-pin","title":"Reset pin","text":"Method Arguments Returns Dependencies Level Repeat Resets the pin for the wallet with a new pin by using the existing pin <code>pin</code> - The current pin for the wallet, <code>new_pin</code> - The new pin to set for the wallet Wallet initialization Usage Application RustJavaTypescriptSwift <p>change_pin</p> <p>pinReset</p> <p>resetPin</p> <p>Not available yet!</p> <pre><code>public func resetPin(pin: String, new_pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-wallet-password","title":"Set wallet password","text":"Method Arguments Returns Dependencies Level Repeat Set the password for the wallet using the provided pin and new password. If the password is already set, this changes it to the new password. Use <code>is_wallet_password_set</code> to check if the password is already set. <code>pin</code> - The new or existing PIN for the wallet, <code>new_password</code> - The new password to set for the wallet Wallet initialization Usage Application RustJavaTypescriptSwift <p>set_wallet_password</p> <p>setWalletPassword</p> <p>setWalletPassword</p> <p>Not available yet!</p> <pre><code>public func setWalletPassword(pin: String, new_password: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#is-wallet-password-set","title":"Is wallet password set","text":"Method Arguments Returns Dependencies Level Repeat Check if the password is already set. Useful to prompt the user to setup one if it has not yet been done. See also <code>set_wallet_password</code> for how to set a new password and change an existing password. Returns <code>true</code> or <code>false</code> whether or not the password is already set. Wallet initialization Usage Application RustJavaTypescriptSwift <p>is_wallet_password_set</p> <p>isWalletPasswordSet</p> <p>isWalletPasswordSet</p> <p>Not available yet!</p> <pre><code>public func isWalletPasswordSet() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#generate-a-new-address","title":"Generate a new address","text":"Method Arguments Returns Dependencies Level Repeat Generates a new receiver address for the wallet based on the selected network. <code>pin</code> - The PIN for the wallet Returns the generated address as a <code>String</code> if successful. Wallet initialization, Set network Usage Application RustJavaTypescriptSwift <p>generate_new_address</p> <p>generateNewAddress</p> <p>generateNewAddress</p> <p>Not available yet!</p> <pre><code>public func generateNewAddress(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-balance","title":"Get balance","text":"Method Arguments Returns Dependencies Level Repeat Fetches the balance of the user from the wallet <code>pin</code> - The PIN for the wallet Returns the balance as a <code>f64</code> if successful. Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_balance</p> <p>getWalletBalance</p> <p>getWalletBalance</p> <p>Not available yet!</p> <pre><code>public func getBalance(pin: String) throws -&gt; Float\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-wallet-transactions","title":"Get wallet transactions","text":"Method Arguments Returns Dependencies Level Repeat Wallet transaction list <code>pin</code> - The PIN for the wallet, <code>start</code> - The starting page number for paginatation, <code>limit</code> - The page limit size for each page Returns the list of transactions made on the wallet as an array of <code>WalletTxInfo</code> object or a serialized JSON of the same, if successful. Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_wallet_tx_list</p> <p>getWalletTransactionList</p> <p>getWalletTransactionList</p> <p>Not available yet!</p> <pre><code>public func getWalletTransactionList(pin: String, start: UInt64, limit: UInt64) throws -&gt; Rustvec&lt;WalletTxInfo&gt;\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#wallettxinfo","title":"WalletTxInfo","text":"RustJSON <pre><code>pub struct WalletTxInfo {\n/// Transaction creation date\npub date: String,\n/// Contains block id\npub block_id: Option&lt;String&gt;,\n/// Transaction id for particular transaction\npub transaction_id: String,\n/// Describes type of transaction\npub incoming: bool,\n/// Amount of transfer\npub amount: f64,\n/// Unique key representing a network\npub network_key: String,\n/// Status of the transfer\npub status: String,\n/// Url of network\npub explorer_url: Option&lt;String&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"&lt;http://json-schema.org/draft-07/schema#&gt;\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"date\": {\n            \"type\": \"string\",\n            \"description\": \"Transaction creation date\"\n        },\n        \"block_id\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Contains block id\"\n        },\n        \"transaction_id\": {\n            \"type\": \"string\",\n            \"description\": \"Transaction id for particular transaction\"\n        },\n        \"incoming\": {\n            \"type\": \"boolean\",\n            \"description\": \"Describes type of transaction\"\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"Amount of transfer\"\n        },\n        \"network_key\": {\n            \"type\": \"string\",\n            \"description\": \"Unique key representing a network\"\n        },\n        \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status of the transfer\"\n        },\n        \"explorer_url\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Url of network\"\n        }\n    },\n    \"required\": [\"date\", \"transaction_id\", \"incoming\", \"amount\", \"network\", \"status\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-wallet-transaction","title":"Get wallet transaction","text":"Method Arguments Returns Dependencies Level Repeat Single wallet transaction <code>pin</code> - The PIN for the wallet, <code>tx_id</code> - The transaction id on the network Returns the transactions made on the wallet with the given id as <code>WalletTxInfo</code> object or a serialized JSON of the same, if successful. Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_wallet_tx</p> <p>getWalletTransaction</p> <p>getWalletTransaction</p> <p>Not available yet!</p> <pre><code>public func getWalletTransaction(pin: String, transactionId: String) throws -&gt; WalletTxInfo\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-recovery-share","title":"Set recovery share","text":"Method Arguments Returns Dependencies Level Repeat Sets the recovery share for the users wallet. <code>share</code> - The recovery share to upload. User initialization Usage Application RustJavaTypescriptSwift <p>set_recovery_share</p> <p>setRecoveryShare</p> <p>setRecoveryShare</p> <p>Not available yet!</p> <pre><code>public func setRecoveryShare(share: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-recovery-share","title":"Get recovery share","text":"Method Arguments Returns Dependencies Level Repeat Get the recovery share for the users wallet. User initialization Usage Application RustJavaTypescriptSwift <p>get_recovery_share</p> <p>getRecoveryShare</p> <p>getRecoveryShare</p> <p>Not available yet!</p> <pre><code>public func getRecoveryShare() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswap-functions","title":"Viviswap functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#start-kyc-verification-for-viviswap","title":"Start KYC Verification for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Create a new viviswap user and initialize KYC verification <code>mail</code> - The email address of the user, <code>terms_accepted</code> - A boolean indicating whether the terms have been accepted Returns <code>NewViviswapUser</code> object if successful. User initialization Usage Application RustJavaTypescriptSwift <p>start_kyc_verification_for_viviswap</p> <p>startViviswapKyc</p> <p>startKycVerificationForViviswap</p> <p>Not available yet!</p> <pre><code>public func startKycVerificationForViviswap(mail: String, termsAccepted: Bool) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#newviviswapuser","title":"NewViviswapUser","text":"RustJSON <pre><code>pub struct NewViviswapUser {\n/// Username of new viviswap user\npub username: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"&lt;http://json-schema.org/draft-07/schema#&gt;\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Username of new viviswap user\"\n        }\n    },\n    \"required\": [\"username\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-kyc-details-for-viviswap","title":"Get KYC details for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Get current kyc status of viviswap Returns <code>ViviswapKycStatus</code> object if successful. User initialization Usage Application RustJavaTypescriptSwift <p>get_kyc_details_for_viviswap</p> <p>getViviswapKyc</p> <p>getKycDetailsForViviswap</p> <p>Not available yet!</p> <pre><code>public func getKycDetailsForViviswap() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapkycstatus","title":"ViviswapKycStatus","text":"RustJSON <pre><code>pub struct ViviswapKycStatus {\n    /// full name of the user\n    pub full_name: String,\n    /// the current submission step in the KYC onboarding process for the user\n    pub submission_step: ViviswapVerificationStep,\n    /// the current verified step in the KYC onboarding process for the user\n    pub verified_step: ViviswapVerificationStep,\n    /// the user verification status\n    pub verification_status: ViviswapVerificationStatus,\n    /// The monthly swap limit in euros\n    pub monthly_limit_eur: f32,\n}\npub enum ViviswapVerificationStep {\n    /// no verification step (no next verification step available)\n    Undefined,\n    /// general verification step\n    General,\n    /// personal verification step\n    Personal,\n    /// residence verification step\n    Residence,\n    /// identity verification step\n    Identity,\n    /// amla general verification step\n    Amla,\n    /// document verification step\n    Documents,\n}\npub enum ViviswapVerificationStatus {\n    /// The user is fully verified\n    Verified,\n    /// The user is not verified\n    Unverified,\n    /// The user is partially verified\n    PartiallyVerified,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"full_name\": {\n            \"type\": \"string\",\n            \"description\": \"Full name of the user\"\n        },\n        \"submission_step\": {\n            \"type\": \"string\",\n            \"enum\": [\"Undefined\", \"General\", \"Personal\", \"Residence\", \"Identity\", \"Amla\", \"Documents\"],\n            \"description\": \"The current submission step in the KYC onboarding process for the user\"\n        },\n        \"verified_step\": {\n            \"type\": \"string\",\n            \"enum\": [\"Undefined\", \"General\", \"Personal\", \"Residence\", \"Identity\", \"Amla\", \"Documents\"],\n            \"description\": \"The current verified step in the KYC onboarding process for the user\"\n        },\n        \"verification_status\": {\n            \"type\": \"string\",\n            \"enum\": [\"Verified\", \"Unverified\", \"PartiallyVerified\"],\n            \"description\": \"The user verification status\"\n        },\n        \"monthly_limit_eur\": {\n            \"type\": \"number\",\n            \"description\": \"The monthly swap limit in euros\"\n        }\n    },\n    \"required\": [\"full_name\", \"submission_step\", \"verified_step\", \"verification_status\", \"monthly_limit_eur\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-partial-kyc-for-viviswap","title":"Update partial KYC for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Update the kyc details for viviswap to be submitted <code>is_individual</code> - Whether the user is an individual, <code>is_pep</code> - Whether the user is a politically exposed person, <code>is_us_citizen</code> - Whether the user is a US citizen, <code>is_regulatory_disclosure</code> - Whether the user has accepted the regulatory disclosure, <code>country_of_residence</code> - The country of residence of the user, <code>nationality</code> - The nationality of the user, <code>full_name</code> - The full name of the user, <code>date_of_birth</code> - The date of birth of the user Returns <code>ViviswapPartiallyKycDetails</code> object containing the partially updated KYC details. User initialization Usage Application RustJavaTypescriptSwift <p>update_kyc_partially_status_for_viviswap</p> <p>updateViviswapKycPartial</p> <p>updateKycPartiallyStatusForViviswap</p> <p>Not available yet!</p> <pre><code>public func updateKycPartiallyStatusForViviswap(\n    isIndividual: Bool,\n    isPep: Bool,\n    isUsCitizen: Bool,\n    isRegulatoryDisclosure: Bool,\n    countryOfResidence: String,\n    nationality: String,\n    fullName: String,\n    dateOfBirth: String\n) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswappartiallykycdetails","title":"ViviswapPartiallyKycDetails","text":"RustJSON <pre><code>pub struct ViviswapPartiallyKycDetails {\n    /// Is the user an individual\n    pub is_individual: Option&lt;bool&gt;,\n    /// Is the user a politically exposed person\n    pub is_pep: Option&lt;bool&gt;,\n    /// Is the user a US citizen\n    pub is_us_citizen: Option&lt;bool&gt;,\n    /// Is the regulatory disclosure confirmed by user\n    pub is_regulatory_disclosure: Option&lt;bool&gt;,\n    /// The country of tax residence of the user\n    pub country_of_residence: Option&lt;String&gt;,\n    /// The user's nationality\n    pub nationality: Option&lt;String&gt;,\n    /// The full name of the user as per his legal documents\n    pub full_name: Option&lt;String&gt;,\n    /// The date of birth of the user as per his legal documents\n    pub date_of_birth: Option&lt;String&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"is_individual\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user an individual\"\n        },\n        \"is_pep\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user a politically exposed person\"\n        },\n        \"is_us_citizen\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user a US citizen\"\n        },\n        \"is_regulatory_disclosure\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the regulatory disclosure confirmed by user\"\n        },\n        \"country_of_residence\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The country of tax residence of the user\"\n        },\n        \"nationality\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The user's nationality\"\n        },\n        \"full_name\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The full name of the user as per his legal documents\"\n        },\n        \"date_of_birth\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The date of birth of the user as per his legal documents\"\n        }\n    }\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#submit-partial-kyc-for-viviswap","title":"Submit partial KYC for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Submit the kyc details for viviswap User initialization Usage Application RustJavaTypescriptSwift <p>submit_kyc_partially_status_for_viviswap</p> <p>submitViviswapKycPartial</p> <p>submitKycPartiallyStatusForViviswap</p> <p>Not available yet!</p> <pre><code>public func submitKycPartiallyStatusForViviswap() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-iban-for-viviswap","title":"Get IBAN for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Get current iban of viviswap user Returns <code>ViviswapAddressDetail</code> object if successful. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>get_iban_for_viviswap</p> <p>getIbanViviswap</p> <p>getIbanViviswap</p> <p>Not available yet!</p> <pre><code>public func getIbanViviswap() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapaddressdetail","title":"ViviswapAddressDetail","text":"RustJSON <pre><code>pub struct ViviswapAddressDetail {\n    /// the unique id of the address detail\n    pub id: String,\n    /// the address used in the detail\n    pub address: String,\n    /// the status from viviswap, whether the address is verified\n    pub is_verified: bool,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique id of the address detail\"\n        },\n        \"address\": {\n            \"type\": \"string\",\n            \"description\": \"The address used in the detail\"\n        },\n        \"is_verified\": {\n            \"type\": \"boolean\",\n            \"description\": \"The status from viviswap, whether the address is verified\"\n        }\n    },\n    \"required\": [\"id\", \"address\", \"is_verified\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-iban-for-viviswap","title":"Update IBAN for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Update IBAN of viviswap user <code>pin</code> - The user's PIN, <code>address</code> - The new IBAN address Returns <code>ViviswapAddressDetail</code> object if successful. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>update_iban_for_viviswap</p> <p>updateIbanViviswap</p> <p>updateIbanViviswap</p> <p>Not available yet!</p> <pre><code>public func updateIbanViviswap(pin: String, address: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-deposit-with-viviswap","title":"Create deposit with viviswap","text":"Method Arguments Returns Dependencies Level Repeat Create deposit for viviswap user <code>pin</code> - The PIN for the wallet Returns <code>ViviswapDeposit</code> object if successful. Wallet initialization, Get KYC Details for viviswap, Update IBAN Usage Application RustJavaTypescriptSwift <p>create_deposit_with_viviswap</p> <p>depositWithViviswap</p> <p>createDepositWithViviswap</p> <p>Not available yet!</p> <pre><code>public func depositWithViviswap(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapdeposit","title":"ViviswapDeposit","text":"RustJSON <pre><code>pub struct ViviswapDeposit {\n    /// The unique UUID of the contract\n    pub contract_id: String,\n    /// The deposit address (crypto) where the swap will put the funds from fiat\n    pub deposit_address: String,\n    /// The details of the deposit (for the user)\n    pub details: ViviswapDepositDetails,\n}\npub struct ViviswapDepositDetails {\n    /// The reference to be entered by the user in his SEPA bank transfer\n    pub reference: String,\n    /// The name of the beneficiary receiving the SEPA transfer\n    pub beneficiary: String,\n    /// The name of the bank of the beneficiary\n    pub name_of_bank: String,\n    /// The address of the bank of the beneficiary\n    pub address_of_bank: String,\n    /// The IBAN of the beneficiary\n    pub iban: String,\n    /// The BIC/SWIFT code for the SEPA transfer\n    pub bic: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique UUID of the contract\"\n        },\n        \"deposit_address\": {\n            \"type\": \"string\",\n            \"description\": \"The deposit address (crypto) where the swap will put the funds from fiat\"\n        },\n        \"details\": {\n            \"type\": \"object\",\n            \"description\": \"The details of the deposit (for the user)\",\n            \"properties\": {\n                \"reference\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reference to be entered by the user in his SEPA bank transfer\"\n                },\n                \"beneficiary\": {\n                    \"type\": \"string\",\n                    \"description\": \"The name of the beneficiary receiving the SEPA transfer\"\n                },\n                \"name_of_bank\": {\n                    \"type\": \"string\",\n                    \"description\": \"The name of the bank of the beneficiary\"\n                },\n                \"address_of_bank\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the bank of the beneficiary\"\n                },\n                \"iban\": {\n                    \"type\": \"string\",\n                    \"description\": \"The IBAN of the beneficiary\"\n                },\n                \"bic\": {\n                    \"type\": \"string\",\n                    \"description\": \"The BIC/SWIFT code for the SEPA transfer\"\n                }\n            },\n            \"required\": [\"reference\", \"beneficiary\", \"name_of_bank\", \"address_of_bank\", \"iban\", \"bic\"]\n        }\n    },\n    \"required\": [\"contract_id\", \"deposit_address\", \"details\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-viviswap-address-detail","title":"Create viviswap address detail","text":"Method Arguments Returns Dependencies Level Repeat Create address detail for viviswap user <code>pin</code> - The PIN for the wallet Returns <code>ViviswapAddressDetail</code> object if successful. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>create_detail_for_viviswap</p> <p>createViviswapDetail</p> <p>createDetailForViviswap</p> <p>Not available yet!</p> <pre><code>public func createViviswapDetail(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-withdrawal-with-viviswap","title":"Create withdrawal with viviswap","text":"Method Arguments Returns Dependencies Level Repeat Create address detail for viviswap user <code>amount</code> - The amount of the withdrawal, <code>pin</code> - The optional PIN for verification, <code>data</code> - Optional data which can be assigned to the transaction Returns <code>ViviswapWithdrawal</code> object if successful. Wallet initialization, Get KYC Details for viviswap, Update IBAN Usage Application RustJavaTypescriptSwift <p>create_withdrawal_with_viviswap</p> <p>withdrawWithViviswap</p> <p>createWithdrawalWithViviswap</p> <p>Not available yet!</p> <pre><code>public func withdrawWithViviswap(amount: Float, pin: String, data: [UInt8]) throws -&gt; ViviswapWithdrawal\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapwithdrawal","title":"ViviswapWithdrawal","text":"RustJSON <pre><code>pub struct ViviswapWithdrawal {\n    /// The unique UUID to track the withdrawal contract\n    pub contract_id: String,\n    /// The deposit address, in this case the IBAN of the user, where fiat will be deposited.\n    pub deposit_address: String,\n    /// The details of the withdrawal\n    pub details: ViviswapWithdrawalDetails,\n}\npub struct ViviswapWithdrawalDetails {\n    /// The reference used by viviswap for the SEPA transfer\n    pub reference: String,\n    /// The id of the unique wallet internal to viviswap\n    pub wallet_id: String,\n    /// The crypto address of viviswap where the crypto swap is to be sent\n    pub crypto_address: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique UUID of the contract\"\n        },\n        \"withdrawal_address\": {\n            \"type\": \"string\",\n            \"description\": \"The withdrawal address (crypto) where the swap will put the funds from fiat\"\n        },\n        \"details\": {\n            \"type\": \"object\",\n            \"description\": \"The details of the withdrawal (for the user)\",\n            \"properties\": {\n                \"reference\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reference used by viviswap for the SEPA transfer\"\n                },\n                \"wallet_id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The id of the unique wallet internal to viviswap\"\n                },\n                \"crypto_address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The crypto address of viviswap where the crypto swap is to be sent\"\n                }\n            },\n            \"required\": [\"reference\", \"wallet_id\", \"crypto_address\"]\n        }\n    },\n    \"required\": [\"contract_id\", \"withdrawal_address\", \"details\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-swap-details","title":"Get swap details","text":"Method Arguments Returns Dependencies Level Repeat Get swap details <code>order_id</code> - The ID of the swap order. Returns <code>Order</code> object containing the swap order details. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>get_swap_details</p> <p>getSwapDetails</p> <p>getSwapDetails</p> <p>Not available yet!</p> <pre><code>public func getSwapDetails(order_id: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#order","title":"Order","text":"RustJSON <pre><code>pub struct Order {\n    pub id: String,\n    pub is_payed_out: bool,\n    pub is_approved: bool,\n    pub is_canceled: bool,\n    pub fees_amount_eur: f32,\n    pub crypto_fees: f32,\n    pub contract_id: String,\n    pub incoming_payment_method_id: String,\n    pub incoming_payment_method_currency: String,\n    pub incoming_amount: f32,\n    pub incoming_course: f32,\n    pub outgoing_payment_method_id: String,\n    pub outgoing_payment_method_currency: String,\n    pub outgoing_amount: f32,\n    pub outgoing_course: f32,\n    pub refund_amount: Option&lt;f32&gt;,\n    pub refund_course: Option&lt;f32&gt;,\n    pub refund_payment_method_id: Option&lt;String&gt;,\n    pub status: i32,\n    pub creation_date: String,\n    pub incoming_payment_detail: Option&lt;PaymentDetail&gt;,\n    pub outgoing_payment_detail: Option&lt;PaymentDetail&gt;,\n    pub refund_payment_detail: Option&lt;PaymentDetail&gt;,\n}\n\npub struct PaymentDetail {\n    pub id: String,\n    pub address: String,\n    pub is_verified: Option&lt;bool&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique id of the order\"\n        },\n        \"is_payed_out\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is payed out\"\n        },\n        \"is_approved\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is approved\"\n        },\n        \"is_canceled\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is canceled\"\n        },\n        \"fees_amount_eur\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of fees in EUR\"\n        },\n        \"crypto_fees\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of crypto fees\"\n        },\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the contract\"\n        },\n        \"incoming_payment_method_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the incoming payment method\"\n        },\n        \"incoming_payment_method_currency\": {\n            \"type\": \"string\",\n            \"description\": \"The currency of the incoming payment method\"\n        },\n        \"incoming_amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of the incoming payment\"\n        },\n        \"incoming_course\": {\n            \"type\": \"number\",\n            \"description\": \"The course of the incoming payment\"\n        },\n        \"outgoing_payment_method_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the outgoing payment method\"\n        },\n        \"outgoing_payment_method_currency\": {\n            \"type\": \"string\",\n            \"description\": \"The currency of the outgoing payment method\"\n        },\n        \"outgoing_amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of the outgoing payment\"\n        },\n        \"outgoing_course\": {\n            \"type\": \"number\",\n            \"description\": \"The course of the outgoing payment\"\n        },\n        \"refund_amount\": {\n            \"type\": [\"number\", \"null\"],\n            \"description\": \"The amount of the refund\"\n        },\n        \"refund_course\": {\n            \"type\": [\"number\", \"null\"],\n            \"description\": \"The course of the refund\"\n        },\n        \"refund_payment_method_id\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The id of the refund payment method\"\n        },\n        \"status\": {\n            \"type\": \"integer\",\n            \"description\": \"The status of the order\"\n        },\n        \"creation_date\": {\n            \"type\": \"string\",\n            \"description\": \"The creation date of the order\"\n        },\n        \"incoming_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the incoming payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        },\n        \"outgoing_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the outgoing payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        },\n        \"refund_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the refund payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        }\n    },\n    \"required\": [\"id\", \"is_payed_out\", \"is_approved\", \"is_canceled\", \"fees_amount_eur\", \"crypto_fees\", \"contract_id\", \"incoming_payment_method_id\", \"incoming_payment_method_currency\", \"incoming_amount\", \"incoming_course\", \"outgoing_payment_method_id\", \"outgoing_payment_method_currency\", \"outgoing_amount\", \"outgoing_course\", \"status\", \"creation_date\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-swap-lists","title":"Get swap lists","text":"Method Arguments Returns Dependencies Level Repeat Get swap list <code>start</code> - The start page parameter, <code>limit</code> - The pagination limit parameter Returns an array of <code>Order</code> object containing the swap order details for each swap. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>get_swap_list</p> <p>getSwapList</p> <p>getSwapList</p> <p>Not available yet!</p> <pre><code>public func getSwapList(page: UInt64, limit: UInt64) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-exchange-rate","title":"Get exchange rate","text":"Method Arguments Returns Dependencies Level Repeat Get the exchange rate for the selected currency Returns the latest exchange rate Usage Application RustJavaTypescriptSwift <p>get_exchange_rate</p> <p>getExchangeRate</p> <p>getExchangeRate</p> <p>Not available yet!</p> <pre><code>public func getExchangeRate() throws -&gt; Float\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#transaction-functions","title":"Transaction functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-purchase-request","title":"Create purchase request","text":"Method Arguments Returns Dependencies Level Repeat Create purchase request <code>receiver</code> - The receiver's username, <code>amount</code> - The amount of the purchase, <code>product_hash</code> - The hash of the product, <code>app_data</code> - The application data, <code>purchase_type</code> - The type of the purchase Returns the purchase ID. This is an internal index used to reference the transaction in etopay Wallet initialization Usage Application RustJavaTypescriptSwift <p>create_purchase_request</p> <p>purchaseRequestCreate</p> <p>createPurchaseRequest</p> <p>Not available yet!</p> <pre><code>public func createPurchaseRequest(\n    receiver: String, amount: Double, product_hash: String, app_data: String, purchase_type: String\n) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-purchase-details","title":"Get purchase details","text":"Method Arguments Returns Dependencies Level Repeat Get purchase details <code>purchase_id</code> - The ID of the purchase. Returns the purchase details as <code>PurchaseDetails</code> object Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_purchase_details</p> <p>purchaseDetails</p> <p>getPurchaseDetails</p> <p>Not available yet!</p> <pre><code>public func getPurchaseDetails(purchase_id: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#purchasedetails","title":"PurchaseDetails","text":"RustJSON <pre><code>    pub struct PurchaseDetails {\n        /// The sender address where the fees goes to.\n        pub system_address: String,\n        /// The amount to be paid.\n        pub amount: Decimal,\n        /// The status of transaction\n        pub status: ApiTxStatus,\n    }\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"system_address\": {\n            \"type\": \"string\",\n            \"description\": \"The sender address where the fees goes to.\"\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount to be paid\"\n        },\n        \"status\": {\n            \"type\": \"object\",\n            \"description\": \"Status of the transfer\",\n            \"enum\": [\"Pending\", \"WaitingForVerification\", \"Valid\", \"Invalid\", \"ProcessingIncoming\", \"ProcessingOutgoing\", \"Completed\", \"Failed\"]\n        },\n    },\n    \"required\": [\"system_address\", \"amount\", \"status\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#confirm-purchase-request","title":"Confirm purchase request","text":"Method Arguments Returns Dependencies Level Repeat Confirm purchase request <code>pin</code> - The PIN of the user, <code>purchase_id</code> - The ID of the purchase. Wallet initialization Usage Application RustJavaTypescriptSwift <p>confirm_purchase_request</p> <p>purchaseRequestConfirm</p> <p>confirmPurchaseRequest</p> <p>Not available yet!</p> <pre><code>public func confirmPurchaseRequest(pin: String, purchase_id: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#send-amount","title":"Send amount","text":"Method Arguments Returns Dependencies Level Repeat Send amount to the receiver address. <code>pin</code> - The PIN of the user, <code>address</code> - The receiver's address, <code>amount</code> - The amount to send, <code>data</code> - Optional data which can be assigned to the transaction Wallet initialization Usage Application RustJavaTypescriptSwift <p>send_amount</p> <p>sendAmount</p> <p>sendAmount</p> <p>Not available yet!</p> <pre><code>public func sendAmount(pin: String, address: String, amount: Double, data: [UInt8]) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-purchase-list","title":"Get Purchase list","text":"Method Arguments Returns Dependencies Level Repeat Get purchase list <code>start</code> - The starting page number, <code>limit</code> - The maximum number of transactions per page Returns a list of purchases as <code>TxInfo</code> object, if successful. User initialization Usage Application RustJavaTypescriptSwift <p>get_tx_list</p> <p>txList</p> <p>getTransactionList</p> <p>Not available yet!</p> <pre><code>public func getTxList(start: UInt64, limit: UInt64) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#txinfo","title":"TxInfo","text":"RustJSON <pre><code>pub struct TxInfo {\n    /// Tx creation date, if available\n    pub date: Option&lt;String&gt;,\n    /// receiver of the transaction\n    pub receiver: String,\n    /// etopay reference id for the transaction\n    pub reference_id: String,\n    /// Application specific metadata attached to the tx\n    pub application_metadata: Option&lt;ApplicationMetadata&gt;,\n    /// Amount of transfer\n    pub amount: f64,\n    /// Currency of transfer\n    pub currency: String,\n    /// Status of the transfer\n    pub status: TxStatus,\n    /// The transaction hash on the network\n    pub transaction_hash: Option&lt;String&gt;,\n    /// Exchange rate\n    pub course: f64,\n}\n\npub struct ApplicationMetadata {\n    pub product_hash: String,\n    pub reason: String,\n    pub purchase_model: String,\n    pub app_data: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"date\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Tx creation date, if available\"\n        },\n        \"receiver\": {\n            \"type\": \"string\",\n            \"description\": \"receiver of the transaction\"\n        },\n        \"reference_id\": {\n            \"type\": \"string\",\n            \"description\": \"etopay reference id for the transaction\"\n        },\n        \"application_metadata\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"Application specific metadata attached to the tx\",\n            \"properties\": {\n                \"product_hash\": {\n                    \"type\": \"string\",\n                    \"description\": \"The product hash\"\n                },\n                \"reason\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reason for the transaction\"\n                },\n                \"purchase_model\": {\n                    \"type\": \"string\",\n                    \"description\": \"The purchase model\"\n                },\n                \"app_data\": {\n                    \"type\": \"string\",\n                    \"description\": \"The application data\"\n                }\n            },\n            \"required\": [\"product_hash\", \"reason\", \"purchase_model\", \"app_data\"]\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"Amount of transfer\"\n        },\n        \"currency\": {\n            \"type\": \"string\",\n            \"description\": \"Currency of transfer\"\n        },\n        \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status of the transfer\",\n            \"enum\": [\"Pending\", \"Valid\", \"Invalid\", \"ProcessingMain\", \"ProcessingAux\", \"Completed\", \"Failed\"]\n        },\n        \"transaction_hash\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The transaction hash on the network\"\n        },\n        \"course\": {\n            \"type\": \"number\",\n            \"description\": \"Exchange rate\"\n        }\n    },\n    \"required\": [\"receiver\", \"reference_id\", \"amount\", \"currency\", \"status\", \"course\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#postident-functions","title":"Postident functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#start-kyc-verification-for-postident","title":"Start kyc verification for postident","text":"Method Arguments Returns Dependencies Level Repeat Start kyc verification for postident Returns an object <code>NewCaseIdResponse</code> if successful. User initialization Usage Application RustJavaTypescriptSwift <p>start_kyc_verification_for_postident</p> <p>startKycVerificationForPostident</p> <p>startKycVerificationForPostident</p> <p>Not available yet!</p> <pre><code>public func startKycVerificationForPostident() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#newcaseidresponse","title":"NewCaseIdResponse","text":"RustJSON <pre><code>pub struct NewCaseIdResponse {\n    /// New Postident case id\n    pub case_id: String,\n    /// Case url\n    pub case_url: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"case_id\": {\n            \"type\": \"string\",\n            \"description\": \"New Postident case id\"\n        },\n        \"case_url\": {\n            \"type\": \"string\",\n            \"description\": \"Case url\"\n        }\n    },\n    \"required\": [\"case_id\", \"case_url\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-case-details-for-postident","title":"Get case details for postident","text":"Method Arguments Returns Dependencies Level Repeat Get case details for postident Returns an object <code>CaseDetailsResponse</code> if successful. User initialization Usage Application RustJavaTypescriptSwift <p>get_kyc_details_for_postident</p> <p>getKycDetailsForPostident</p> <p>getKycDetailsForPostident</p> <p>Not available yet!</p> <pre><code>public func getKycDetailsForPostident() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#casedetailsresponse","title":"CaseDetailsResponse","text":"RustJSON <pre><code>pub struct CaseDetailsResponse {\n    pub case_id: String,\n    pub archived: bool,\n    pub status: String,\n}\n</code></pre> <pre><code>    {\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n        \"type\": \"object\",\n        \"properties\": {\n            \"case_id\": {\n                \"type\": \"string\",\n                \"description\": \"The Postident case id\"\n            },\n            \"archived\": {\n                \"type\": \"boolean\",\n                \"description\": \"Whether the case is archived\"\n            },\n            \"status\": {\n                \"type\": \"string\",\n                \"description\": \"The status of the case\"\n            }\n        },\n        \"required\": [\"case_id\", \"archived\", \"status\"]\n    }\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-case-status-for-postident","title":"Update case status for postident","text":"Method Arguments Returns Dependencies Level Repeat Update case status for postident <code>case_id</code>: The ID of the case to update. User initialization Usage Application RustJavaTypescriptSwift <p>update_kyc_status_for_postident</p> <p>updateKycStatusForPostident</p> <p>updateKycStatusForPostident</p> <p>Not available yet!</p> <pre><code>public func updateKycStatusForPostident(case_id: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-user-preferred-network","title":"Get user preferred network","text":"Method Arguments Returns Dependencies Level Repeat Fetches the users preferred network Returns the network if successful or an empty value if no preferred network has been set. User initialization Usage Application RustJavaTypescriptSwift <p>get_preferred_network</p> <p>getPreferredNetwork</p> <p>getPreferredNetwork</p> <p>Not available yet!</p> <pre><code>public func getPreferredNetwork() throws -&gt; PreferredNetwork\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-user-preferred-network","title":"Set user preferred network","text":"Method Arguments Returns Dependencies Level Repeat Sets the users preferred network, or resets it if an empty value is provided. <code>network_key</code> - The preferred user network. Optional value. User initialization Usage Application RustJavaTypescriptSwift <p>set_preferred_network</p> <p>setPreferredNetwork</p> <p>setPreferredNetwork</p> <p>Not available yet!</p> <pre><code>public func setPreferredNetwork(network_key: String) throws\n</code></pre>"},{"location":"javadoc/legal/jquery/","title":"Jquery","text":""},{"location":"javadoc/legal/jquery/#jquery-v371","title":"jQuery v3.7.1","text":""},{"location":"javadoc/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.7.1\nCopyright OpenJS Foundation and other contributors, https://openjsf.org/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"javadoc/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"javadoc/legal/jqueryUI/#jquery-ui-v1132","title":"jQuery UI v1.13.2","text":""},{"location":"javadoc/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"},{"location":"rust-docs/doc/static.files/SourceSerif4-LICENSE-a2cfd9d5/","title":"SourceSerif4 LICENSE a2cfd9d5","text":"<p>Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries. Copyright 2014 - 2023 Adobe (http://www.adobe.com/), with Reserved Font Name \u2018Source\u2019. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.</p> <p>This Font Software is licensed under the SIL Open Font License, Version 1.1.</p> <p>This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL</p>"},{"location":"rust-docs/doc/static.files/SourceSerif4-LICENSE-a2cfd9d5/#sil-open-font-license-version-11-26-february-2007","title":"SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007","text":"<p>PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.</p> <p>The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.</p> <p>DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.</p> <p>\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).</p> <p>\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).</p> <p>\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.</p> <p>\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.</p> <p>PERMISSION &amp; CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:</p> <p>1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.</p> <p>2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.</p> <p>3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.</p> <p>4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.</p> <p>5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.</p> <p>TERMINATION This license becomes null and void if any of the above conditions are not met.</p> <p>DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.</p>"}]}